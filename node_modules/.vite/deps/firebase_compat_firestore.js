import {
  Component,
  FirebaseError,
  LogLevel,
  Logger,
  SDK_VERSION,
  _registerComponent,
  createMockUserToken,
  firebase,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isElectron,
  isIE,
  isIndexedDBAvailable,
  isMobileCordova,
  isReactNative,
  isSafari,
  isUWP,
  registerVersion
} from "./chunk-5FH7KTYU.js";
import "./chunk-QOVRSCHT.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm2017.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var esm = {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka = 0;
var la = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), ka != 0)) {
    var a = da(this);
    delete la[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if (typeof a === "string")
    return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
  for (let c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  const d = a.length, e = typeof a === "string" ? a.split("") : a;
  for (let f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    const c = a.length, d = typeof a === "string" ? a.split("") : a;
    for (let e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  const b = a.length;
  if (0 < b) {
    const c = Array(b);
    for (let d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var x;
a: {
  va2 = l.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      x = wa2;
      break a;
    }
  }
  x = "";
}
var va2;
var wa2;
function xa(a, b, c) {
  for (const d in a)
    b.call(c, a[d], d, a);
}
function ya(a) {
  const b = {};
  for (const c in a)
    b[c] = a[c];
  return b;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa(a, b) {
  let c, d;
  for (let e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (let f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ca(a) {
  Ca[" "](a);
  return a;
}
Ca[" "] = aa;
function Fa(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
var Ha = w(x, "Opera");
var y = w(x, "Trident") || w(x, "MSIE");
var Ia = w(x, "Edge");
var Ja = Ia || y;
var Ka = w(x, "Gecko") && !(w(x.toLowerCase(), "webkit") && !w(x, "Edge")) && !(w(x, "Trident") || w(x, "MSIE")) && !w(x, "Edge");
var La = w(x.toLowerCase(), "webkit") && !w(x, "Edge");
function Ma() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa2 = function() {
    var a = x;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa2 && (Oa2 = Pa2 ? Pa2[1] : "");
  if (y) {
    Qa2 = Ma();
    if (Qa2 != null && Qa2 > parseFloat(Oa2)) {
      Na = String(Qa2);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa2;
var Qa2;
var Ga = {};
function Ra() {
  return Fa(function() {
    let a = 0;
    const b = ta(String(Na)).split("."), c = ta("9").split("."), d = Math.max(b.length, c.length);
    for (let h = 0; a == 0 && h < d; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua(e[2].length == 0, f[2].length == 0) || ua(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
var Sa;
if (l.document && y) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
z.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var B = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ia = e;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
$a.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = ab(a, b, d, e);
  -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d, e), b.fa = c, a.push(b));
  return b;
};
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d = a.g[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Za(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d)
      return e;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0);
var db = {};
function fb(a, b, c, d, e) {
  if (d && d.once)
    return gb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.N(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, false, d, e);
}
function ib(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d, h, f);
  if (c.proxy)
    return c;
  d = kb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.O(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, true, d, e);
}
function nb(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = hb(c), a && a[B]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d, e), -1 < c && (Za(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B])
      bb(b.i, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
t(C, v);
C.prototype[B] = true;
C.prototype.removeEventListener = function(a, b, c, d) {
  nb(this, a, b, c, d);
};
function D(a, b) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d, a);
    Aa(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d, true, b) && e;
  e = qb(h, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d, false, b) && e;
}
C.prototype.M = function() {
  C.Z.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Za(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
C.prototype.N = function(a, b, c, d) {
  return this.i.add(String(a), b, false, c, d);
};
C.prototype.O = function(a, b, c, d) {
  return this.i.add(String(a), b, true, c, d);
};
function qb(a, b, c, d) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d) !== false && e;
    }
  }
  return e && !d.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a = tb;
  let b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
var ub = class {
  constructor() {
    this.h = this.g = null;
  }
  add(a, b) {
    const c = vb.get();
    c.set(a, b);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  }
};
var vb = new class {
  constructor(a, b) {
    this.i = a;
    this.j = b;
    this.h = 0;
    this.g = null;
  }
  get() {
    let a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  }
}(() => new wb(), (a) => a.reset());
var wb = class {
  constructor() {
    this.next = this.g = this.h = null;
  }
  set(a, b) {
    this.h = a;
    this.g = b;
    this.next = null;
  }
  reset() {
    this.next = this.g = this.h = null;
  }
};
function yb(a) {
  l.setTimeout(() => {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
var Ab;
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
var Cb = false;
var tb = new ub();
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C);
k = Eb.prototype;
k.da = false;
k.S = null;
k.kb = function() {
  if (this.da) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
k.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(() => {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  const b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
var Ib = class extends v {
  constructor(a, b) {
    super();
    this.m = a;
    this.j = b;
    this.h = null;
    this.i = false;
    this.g = null;
  }
  l(a) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  }
  M() {
    super.M();
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  }
};
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a, b, c, d) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d ? " " + d : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Mb.prototype.info = function() {
};
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
var H = {};
var Rb = null;
function Sb() {
  return Rb = Rb || new C();
}
H.Ma = "serverreachability";
function Tb(a) {
  z.call(this, H.Ma, a);
}
t(Tb, z);
function I(a) {
  const b = Sb();
  D(b, new Tb(b, a));
}
H.STAT_EVENT = "statevent";
function Ub(a, b) {
  z.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
t(Ub, z);
function J(a) {
  const b = Sb();
  D(b, new Ub(b, a));
}
H.Na = "timingevent";
function Vb(a, b) {
  z.call(this, H.Na, a);
  this.size = b;
}
t(Vb, z);
function K(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
var L = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac() {
  z.call(this, "d");
}
t(ac, z);
function bc() {
  z.call(this, "c");
}
t(bc, z);
var cc;
function dc() {
}
t(dc, Yb);
dc.prototype.g = function() {
  return new XMLHttpRequest();
};
dc.prototype.i = function() {
  return {};
};
cc = new dc();
function M(a, b, c, d) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d || 1;
  this.V = new E(this);
  this.P = ec;
  a = Ja ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc();
}
function fc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec = 45e3;
var gc = {};
var hc = {};
k = M.prototype;
k.setTimeout = function(a) {
  this.P = a;
};
function ic(a, b, c) {
  a.K = 1;
  a.v = jc(N(b));
  a.s = c;
  a.U = true;
  kc(a, null);
}
function kc(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N(a.v);
  var c = a.A, d = a.X;
  Array.isArray(d) || (d = [String(d)]);
  mc(c.h, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new fc();
  a.g = nc(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
k.gb = function(a) {
  a = a.target;
  const b = this.L;
  b && O(a) == 3 ? b.l() : this.Ia(a);
};
k.Ia = function(a) {
  try {
    if (a == this.g)
      a: {
        const r = O(this.g);
        var b = this.g.Da();
        const G2 = this.g.ba();
        if (!(3 > r) && (r != 3 || Ja || this.g && (this.h.h || this.g.ga() || oc(this.g)))) {
          this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
          pc(this);
          var c = this.g.ba();
          this.N = c;
          b:
            if (qc(this)) {
              var d = oc(this.g);
              a = "";
              var e = d.length, f = O(this.g) == 4;
              if (!this.h.i) {
                if (typeof TextDecoder === "undefined") {
                  P(this);
                  rc(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b = 0; b < e; b++)
                this.h.h = true, a += this.h.i.decode(d[b], { stream: f && b == e - 1 });
              d.splice(0, e);
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.ga();
          this.i = c == 200;
          Ob(this.j, this.u, this.A, this.m, this.X, r, c);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                F(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc(this, c);
              else {
                this.i = false;
                this.o = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.U ? (tc(this, r, h), Ja && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F(this.j, this.m, h, null), sc(this, h));
            r == 4 && P(this);
            this.i && !this.I && (r == 4 ? uc(this.l, this) : (this.i = false, lc(this)));
          } else
            c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J(12)) : (this.o = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (r) {
  } finally {
  }
};
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc(a, b, c) {
  let d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc) {
      b == 4 && (a.o = 4, J(14), d = false);
      F(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc) {
      a.o = 4;
      J(15);
      F(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.j, a.m, e, null), sc(a, e);
  qc(a) && e != hc && e != gc && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.L = true, J(11))) : (F(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
k.fb = function() {
  if (this.g) {
    var a = O(this.g), b = this.g.ga();
    this.C < b.length && (pc(this), tc(this, a, b), this.i && a != 4 && lc(this));
  }
};
function vc(a, b) {
  var c = a.C, d = b.indexOf("\n", c);
  if (d == -1)
    return hc;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return gc;
  d += 1;
  if (d + c > b.length)
    return hc;
  b = b.substr(d, c);
  a.C = d + c;
  return b;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K(q(a.eb, a), b);
}
function pc(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.eb = function() {
  this.B = null;
  const a = Date.now();
  0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J(17)), P(this), this.o = 2, rc(this)) : xc(this, this.Y - a);
};
function rc(a) {
  a.l.G == 0 || a.I || uc(a.l, a);
}
function P(a) {
  pc(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc(c.i, a))) {
      if (c.I = a.N, !a.J && yc(c.i, a) && c.G == 3) {
        try {
          var d = c.Ca.g.parse(b);
        } catch (m) {
          d = null;
        }
        if (Array.isArray(d) && d.length == 3) {
          var e = d;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K(q(c.ab, c), 6e3));
          if (1 >= Cc(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m) {
            }
            c.ka = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          let m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              const r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              const G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              const Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d = 1.5 * Da2, c.K = d, c.h.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              const ca2 = a.g;
              if (ca2) {
                const Ea2 = ca2.g ? ca2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f = d.i;
                  !f.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f.j = f.l, f.g = /* @__PURE__ */ new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d.D) {
                  const xb = ca2.g ? ca2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d.sa = xb, R(d.F, d.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d = c;
              var h = a;
              d.oa = Ec(d, d.H ? d.la : null, d.W);
              if (h.J) {
                Fc(d.i, h);
                var n = h, u = d.K;
                u && n.setTimeout(u);
                n.B && (pc(n), lc(n));
                d.g = h;
              } else
                Gc(d);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return b;
}
function Kc(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba(a) || typeof a === "string")
    na(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba(a) || typeof a === "string") {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Jc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.T(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
k = S.prototype;
k.R = function() {
  Lc(this);
  for (var a = [], b = 0; b < this.g.length; b++)
    a.push(this.h[this.g[b]]);
  return a;
};
k.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d = a.g[b];
      T(a.h, d) && (a.g[c++] = d);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d = a.g[b], T(e, d) || (a.g[c++] = d, e[d] = 1), b++;
    a.g.length = c;
  }
}
k.get = function(a, b) {
  return T(this.h, a) ? this.h[a] : b;
};
k.set = function(a, b) {
  T(this.h, a) || (this.i++, this.g.push(a));
  this.h[a] = b;
};
k.forEach = function(a, b) {
  for (var c = this.T(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc(c[2] || ""), Pc(this, c[3] || "", true), Qc(this, c[4]), this.l = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
U.prototype.toString = function() {
  var a = [], b = this.j;
  b && a.push(Uc(b, Vc, true), ":");
  var c = this.i;
  if (c || b == "file")
    a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
  if (c = this.l)
    this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc : Xc, true));
  (c = this.h.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc(b, true) : b;
}
function Qc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function bd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc(e, c);
  d && (e.l = d);
  return e;
}
function Tc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S(), a.h = 0, a.i && Nc(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
k = Rc.prototype;
k.add = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b);
  this.h += 1;
  return this;
};
function dd(a, b) {
  V(a);
  b = W(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc(a)));
}
function ed(a, b) {
  V(a);
  b = W(a, b);
  return T(a.g.h, b);
}
k.forEach = function(a, b) {
  V(this);
  this.g.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
k.T = function() {
  V(this);
  for (var a = this.g.R(), b = this.g.T(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
k.R = function(a) {
  V(this);
  var b = [];
  if (typeof a === "string")
    ed(this, a) && (b = qa(b, this.g.get(W(this, a))));
  else {
    a = this.g.R();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
k.set = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  ed(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b]);
  this.h += 1;
  return this;
};
k.get = function(a, b) {
  if (!a)
    return b;
  a = this.R(a);
  return 0 < a.length ? String(a[0]) : b;
};
function mc(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W(a, b), ra(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.R(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      d[f] !== "" && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.i = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), mc(this, e, c));
  }, a));
  a.j = b;
}
var fd = class {
  constructor(a, b) {
    this.h = a;
    this.g = b;
  }
};
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = /* @__PURE__ */ new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
gd.prototype.cancel = function() {
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && this.g.size !== 0) {
    for (const a of this.g.values())
      a.cancel();
    this.g.clear();
  }
};
function jd(a) {
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    let b = a.i;
    for (const c of a.g.values())
      b = b.concat(c.D);
    return b;
  }
  return ra(a.i);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  const d = c || "";
  try {
    Kc(a, function(e, f) {
      let h = e;
      p(e) && (h = rb(e));
      b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  const c = new Mb();
  if (l.Image) {
    const d = new Image();
    d.onload = ja(od, c, d, "TestLoadImage: loaded", true, b);
    d.onerror = ja(od, c, d, "TestLoadImage: error", false, b);
    d.onabort = ja(od, c, d, "TestLoadImage: abort", false, b);
    d.ontimeout = ja(od, c, d, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b(false);
}
function od(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function qd(a, b) {
  C.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C);
var rd = 0;
k = qd.prototype;
k.open = function(a, b) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b;
  this.readyState = 1;
  sd(this);
};
k.send = function(a) {
  if (this.readyState != 1)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  const b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b.body = a);
  (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
  this.readyState = rd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if (this.responseType === "arraybuffer")
      a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b = a.value ? a.value : new Uint8Array(0);
      if (b = this.A.decode(b, { stream: !a.done }))
        this.response = this.responseText += b;
    }
    a.done ? td(this) : sd(this);
    this.readyState == 3 && ud(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, td(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, td(this));
};
k.ha = function() {
  this.g && td(this);
};
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
k.setRequestHeader = function(a, b) {
  this.v.append(a, b);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  const a = [], b = this.h.entries();
  for (var c = b.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
  return a.join("\r\n");
};
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return this.m === "include";
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X(a) {
  C.call(this);
  this.headers = new S();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X, C);
var wd = "";
var xd = /^https?$/i;
var yd = ["POST", "PUT"];
k = X.prototype;
k.ea = function(a, b, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc.g();
  this.C = this.u ? Zb(this.u) : Zb(cc);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b, String(a), true), this.F = false;
  } catch (f) {
    zd(this, f);
    return;
  }
  a = c || "";
  const e = new S(this.headers);
  d && Kc(d, function(f, h) {
    e.set(h, f);
  });
  d = oa(e.T());
  c = l.FormData && a instanceof l.FormData;
  !(0 <= ma(yd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.g.setRequestHeader(h, f);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    zd(this, f);
  }
};
function Bd(a) {
  return y && Ra() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa(a) {
  return a.toLowerCase() == "content-type";
}
k.pa = function() {
  typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D(this, "timeout"), this.abort(8));
};
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D(a, "complete"), D(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D(this, "complete"), D(this, "abort"), Dd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X.Z.M.call(this);
};
k.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k.cb = function() {
  Ed(this);
};
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O(a) != 4 || a.ba() != 2)) {
    if (a.v && O(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D(a, "readystatechange"), O(a) == 4) {
      a.h = false;
      try {
        const n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d;
          if (d = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          D(a, "complete"), D(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    const c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.ba = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Qa = function(a) {
  if (this.g) {
    var b = this.g.responseText;
    a && b.indexOf(a) == 0 && (b = b.substring(a.length));
    return vd(b);
  }
};
function oc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
k.Da = function() {
  return this.m;
};
k.La = function() {
  return typeof this.j === "string" ? this.j : String(this.j);
};
function Fd(a) {
  let b = "";
  xa(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
k = Id.prototype;
k.ma = 8;
k.G = 1;
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc(N(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
k.hb = function(a) {
  try {
    this.h.info("Origin Trials invoked: " + a);
  } catch (b) {
  }
};
function Ac(a) {
  a.g && (wc(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K(q(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
k.Ha = function(a) {
  if (this.m)
    if (this.m = null, this.G == 1) {
      if (!a) {
        this.V = Math.floor(1e5 * Math.random());
        a = this.V++;
        const e = new M(this, this.h, a, void 0);
        let f = this.s;
        this.P && (f ? (f = ya(f), Aa(f, this.P)) : f = this.P);
        this.o === null && (e.H = f);
        if (this.ja)
          a: {
            var b = 0;
            for (var c = 0; c < this.l.length; c++) {
              b: {
                var d = this.l[c];
                if ("__data__" in d.g && (d = d.g.__data__, typeof d === "string")) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (d === void 0)
                break;
              b += d;
              if (4096 < b) {
                b = c;
                break a;
              }
              if (b === 4096 || c === this.l.length - 1) {
                b = c + 1;
                break a;
              }
            }
            b = 1e3;
          }
        else
          b = 1e3;
        b = Pd(this, e, b);
        c = N(this.F);
        R(c, "RID", a);
        R(c, "CVER", 22);
        this.D && R(c, "X-HTTP-Session-Id", this.D);
        Kd(this, c);
        this.o && f && Gd(c, this.o, f);
        Dc(this.i, e);
        this.Ra && R(c, "TYPE", "init");
        this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic(e, c, null)) : ic(e, c, b);
        this.G = 2;
      }
    } else
      this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
};
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  const d = N(a.F);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.U);
  Kd(a, d);
  a.o && a.s && Gd(d, a.o, a.s);
  c = new M(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic(c, d, b);
}
function Kd(a, b) {
  a.j && Kc({}, function(c, d) {
    R(b, d, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d = a.j ? q(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n = true;
      for (let u = 0; u < c; u++) {
        let m = e[u].h;
        const r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d;
}
function Gc(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K(q(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
k.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
    var a = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a);
    this.B = K(q(this.bb, this), a);
  }
};
k.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J(10), Ac(this), Rd(this));
};
function wc(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc(N(b));
  c.s = null;
  c.U = true;
  kc(c, a);
}
k.ab = function() {
  this.v != null && (this.v = null, Ac(this), Bc(this), J(19));
};
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc(a);
    a.g = null;
    var d = 2;
  } else if (yc(a.i, b))
    c = b.D, Fc(a.i, b), d = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d = Sb();
        D(d, new Vb(d, c, b, e));
        Hc(a);
      } else
        Gc(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d == 1 && Nd(a, b) || d == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Od(a, b) {
  let c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d = q(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc(c));
    nd(c.toString(), d);
  } else
    J(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
k.jb = function(a) {
  a ? (this.h.info("Successfully pinged google.com"), J(2)) : (this.h.info("Failed to ping google.com"), J(1));
};
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec(a, b, c) {
  let d = ad(c);
  if (d.i != "")
    b && Pc(d, b + "." + d.i), Qc(d, d.m);
  else {
    const e = l.location;
    d = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e, f) {
    R(d, f, e);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d, b, c);
  R(d, "VER", a.ma);
  Kd(a, d);
  return d;
}
function nc(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X(new pd({ ib: true })) : new X(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
k = Sd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  C.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z(this);
}
t(Y, C);
Y.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b = this.l, c = this.h || void 0;
  a.Wa && (a.h.info("Origin Trials enabled."), zb(q(a.hb, a, b)));
  J(0);
  a.W = b;
  a.aa = c || {};
  a.N = a.X;
  a.F = Ec(a, null, a.W);
  Hc(a);
};
Y.prototype.close = function() {
  Ic(this.g);
};
Y.prototype.u = function(a) {
  if (typeof a === "string") {
    var b = {};
    b.__data__ = a;
    Md(this.g, b);
  } else
    this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
};
Y.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic(this.g);
  delete this.g;
  Y.Z.M.call(this);
};
function Ud(a) {
  ac.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (const c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
t(Ud, ac);
function Vd() {
  bc.call(this);
  this.status = 1;
}
t(Vd, bc);
function Z(a) {
  this.g = a;
}
t(Z, Sd);
Z.prototype.xa = function() {
  D(this.g, "a");
};
Z.prototype.wa = function(a) {
  D(this.g, new Ud(a));
};
Z.prototype.va = function(a) {
  D(this.g, new Vd(a));
};
Z.prototype.ua = function() {
  D(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y.prototype.send = Y.prototype.u;
Y.prototype.open = Y.prototype.m;
Y.prototype.close = Y.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
C.prototype.listen = C.prototype.N;
X.prototype.listenOnce = X.prototype.O;
X.prototype.getLastError = X.prototype.La;
X.prototype.getLastErrorCode = X.prototype.Da;
X.prototype.getStatus = X.prototype.ba;
X.prototype.getResponseJson = X.prototype.Qa;
X.prototype.getResponseText = X.prototype.ga;
X.prototype.send = X.prototype.ea;
var createWebChannelTransport = esm.createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = esm.getStatEventTarget = function() {
  return Sb();
};
var ErrorCode = esm.ErrorCode = Wb;
var EventType = esm.EventType = Xb;
var Event = esm.Event = H;
var Stat = esm.Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = esm.FetchXmlHttpFactory = pd;
var WebChannel = esm.WebChannel = $b;
var XhrIo = esm.XhrIo = X;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var D2 = "@firebase/firestore";
var C2 = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
C2.UNAUTHENTICATED = new C2(null), C2.GOOGLE_CREDENTIALS = new C2("google-credentials-uid"), C2.FIRST_PARTY = new C2("first-party-uid"), C2.MOCK_USER = new C2("mock-user");
var x2 = "9.6.11";
var N2 = new Logger("@firebase/firestore");
function k2() {
  return N2.logLevel;
}
function M2(t2) {
  N2.setLogLevel(t2);
}
function O2(t2, ...e) {
  if (N2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(B2);
    N2.debug(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function F2(t2, ...e) {
  if (N2.logLevel <= LogLevel.ERROR) {
    const n = e.map(B2);
    N2.error(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function $(t2, ...e) {
  if (N2.logLevel <= LogLevel.WARN) {
    const n = e.map(B2);
    N2.warn(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function B2(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function L2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${x2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw F2(e), new Error(e);
}
function U2(t2, e) {
  t2 || L2();
}
function q2(t2, e) {
  t2 || L2();
}
function K2(t2, e) {
  return t2;
}
var G = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var Q2 = class extends FirebaseError {
  constructor(t2, e) {
    super(t2, e), this.code = t2, this.message = e, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var j = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var W2 = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t2}`);
  }
};
var z2 = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var H2 = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var J2 = class {
  constructor(t2) {
    this.t = t2, this.currentUser = C2.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new j();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new j(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t2.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t3) => {
      O2("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t3) => o(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o(t3) : (O2("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new j());
      }
    }, 0), r();
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? (O2("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (U2(typeof e2.accessToken == "string"), new W2(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return U2(t2 === null || typeof t2 == "string"), new C2(t2);
  }
};
var Y2 = class {
  constructor(t2, e, n) {
    this.type = "FirstParty", this.user = C2.FIRST_PARTY, this.headers = /* @__PURE__ */ new Map(), this.headers.set("X-Goog-AuthUser", e);
    const s = t2.auth.getAuthHeaderValueForFirstParty([]);
    s && this.headers.set("Authorization", s), n && this.headers.set("X-Goog-Iam-Authorization-Token", n);
  }
};
var X2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new Y2(this.h, this.l, this.m));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var Z2 = class {
  constructor(t2) {
    this.value = t2, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t2 && t2.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
};
var tt = class {
  constructor(t2) {
    this.g = t2, this.forceRefresh = false, this.appCheck = null, this.p = null;
  }
  start(t2, e) {
    const n = (t3) => {
      t3.error != null && O2("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t3.error.message}`);
      const n2 = t3.token !== this.p;
      return this.p = t3.token, O2("FirebaseAppCheckTokenProvider", `Received ${n2 ? "new" : "existing"} token.`), n2 ? e(t3.token) : Promise.resolve();
    };
    this.o = (e2) => {
      t2.enqueueRetryable(() => n(e2));
    };
    const s = (t3) => {
      O2("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t3, this.appCheck.addTokenListener(this.o);
    };
    this.g.onInit((t3) => s(t3)), setTimeout(() => {
      if (!this.appCheck) {
        const t3 = this.g.getImmediate({
          optional: true
        });
        t3 ? s(t3) : O2("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
      }
    }, 0);
  }
  getToken() {
    const t2 = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t2).then((t3) => t3 ? (U2(typeof t3.token == "string"), this.p = t3.token, new Z2(t3.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
};
var nt = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.I(t3), this.T = (t3) => e.writeSequenceNumber(t3));
  }
  I(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.T && this.T(t2), t2;
  }
};
function st(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
nt.A = -1;
var it = class {
  static R() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = st(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function rt(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function ot(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function ut(t2) {
  return t2 + "\0";
}
var at = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return at.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return at.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new at(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? rt(this.nanoseconds, t2.nanoseconds) : rt(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var ct = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new ct(t2);
  }
  static min() {
    return new ct(new at(0, 0));
  }
  static max() {
    return new ct(new at(253402300799, 999999999));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
function ht(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function lt(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function ft(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
var dt = class {
  constructor(t2, e, n) {
    e === void 0 ? e = 0 : e > t2.length && L2(), n === void 0 ? n = t2.length - e : n > t2.length - e && L2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return dt.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof dt ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var _t = class extends dt {
  construct(t2, e, n) {
    return new _t(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new Q2(G.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new _t(e);
  }
  static emptyPath() {
    return new _t([]);
  }
};
var wt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var mt = class extends dt {
  construct(t2, e, n) {
    return new mt(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return wt.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), mt.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new mt(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (n.length === 0)
        throw new Q2(G.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new Q2(G.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new Q2(G.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        e2 === "`" ? (r = !r, s++) : e2 !== "." || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new Q2(G.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new mt(e);
  }
  static emptyPath() {
    return new mt([]);
  }
};
var gt = class {
  constructor(t2) {
    this.fields = t2, t2.sort(mt.comparator);
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return ot(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
function yt() {
  return typeof atob != "undefined";
}
var pt = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new pt(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new pt(e);
  }
  [Symbol.iterator]() {
    let t2 = 0;
    return {
      next: () => t2 < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t2++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return rt(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
pt.EMPTY_BYTE_STRING = new pt("");
var It = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Tt(t2) {
  if (U2(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = It.exec(t2);
    if (U2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Et(t2.seconds),
    nanos: Et(t2.nanos)
  };
}
function Et(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function At(t2) {
  return typeof t2 == "string" ? pt.fromBase64String(t2) : pt.fromUint8Array(t2);
}
function Rt(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function Pt(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return Rt(e) ? Pt(e) : e;
}
function bt(t2) {
  const e = Tt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new at(e.seconds, e.nanos);
}
var Vt = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = u;
  }
};
var vt = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  static empty() {
    return new vt("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof vt && t2.projectId === this.projectId && t2.database === this.database;
  }
};
function St(t2) {
  return t2 == null;
}
function Dt(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function Ct(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !Dt(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var xt = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new xt(_t.fromString(t2));
  }
  static fromName(t2) {
    return new xt(_t.fromString(t2).popFirst(5));
  }
  static empty() {
    return new xt(_t.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t2) {
    return t2 !== null && _t.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return _t.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new xt(new _t(t2.slice()));
  }
};
var Nt = {
  mapValue: {
    fields: {
      __type__: {
        stringValue: "__max__"
      }
    }
  }
};
var kt = {
  nullValue: "NULL_VALUE"
};
function Mt(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? Rt(t2) ? 4 : Ht(t2) ? 9 : 10 : L2();
}
function Ot(t2, e) {
  if (t2 === e)
    return true;
  const n = Mt(t2);
  if (n !== Mt(e))
    return false;
  switch (n) {
    case 0:
    case 9007199254740991:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return bt(t2).isEqual(bt(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = Tt(t3.timestampValue), s = Tt(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return At(t3.bytesValue).isEqual(At(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return Et(t3.geoPointValue.latitude) === Et(e2.geoPointValue.latitude) && Et(t3.geoPointValue.longitude) === Et(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return Et(t3.integerValue) === Et(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = Et(t3.doubleValue), s = Et(e2.doubleValue);
          return n2 === s ? Dt(n2) === Dt(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return ot(t2.arrayValue.values || [], e.arrayValue.values || [], Ot);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (ht(n2) !== ht(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s[t4] === void 0 || !Ot(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return L2();
  }
}
function Ft(t2, e) {
  return (t2.values || []).find((t3) => Ot(t3, e)) !== void 0;
}
function $t(t2, e) {
  if (t2 === e)
    return 0;
  const n = Mt(t2), s = Mt(e);
  if (n !== s)
    return rt(n, s);
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return rt(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = Et(t3.integerValue || t3.doubleValue), s2 = Et(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return Bt(t2.timestampValue, e.timestampValue);
    case 4:
      return Bt(bt(t2), bt(e));
    case 5:
      return rt(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = At(t3), s2 = At(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = rt(n2[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return rt(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = rt(Et(t3.latitude), Et(e2.latitude));
        if (n2 !== 0)
          return n2;
        return rt(Et(t3.longitude), Et(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = $t(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return rt(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = rt(s2[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = $t(n2[s2[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return rt(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw L2();
  }
}
function Bt(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return rt(t2, e);
  const n = Tt(t2), s = Tt(e), i = rt(n.seconds, s.seconds);
  return i !== 0 ? i : rt(n.nanos, s.nanos);
}
function Lt(t2) {
  return Ut(t2);
}
function Ut(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = Tt(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? At(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, xt.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += Ut(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${Ut(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : L2();
  var e, n;
}
function qt(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function Kt(t2) {
  return !!t2 && "integerValue" in t2;
}
function Gt(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Qt(t2) {
  return !!t2 && "nullValue" in t2;
}
function jt(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Wt(t2) {
  return !!t2 && "mapValue" in t2;
}
function zt(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return lt(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = zt(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = zt(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
function Ht(t2) {
  return (((t2.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__";
}
function Jt(t2) {
  return "nullValue" in t2 ? kt : "booleanValue" in t2 ? {
    booleanValue: false
  } : "integerValue" in t2 || "doubleValue" in t2 ? {
    doubleValue: NaN
  } : "timestampValue" in t2 ? {
    timestampValue: {
      seconds: Number.MIN_SAFE_INTEGER
    }
  } : "stringValue" in t2 ? {
    stringValue: ""
  } : "bytesValue" in t2 ? {
    bytesValue: ""
  } : "referenceValue" in t2 ? qt(vt.empty(), xt.empty()) : "geoPointValue" in t2 ? {
    geoPointValue: {
      latitude: -90,
      longitude: -180
    }
  } : "arrayValue" in t2 ? {
    arrayValue: {}
  } : "mapValue" in t2 ? {
    mapValue: {}
  } : L2();
}
function Yt(t2) {
  return "nullValue" in t2 ? {
    booleanValue: false
  } : "booleanValue" in t2 ? {
    doubleValue: NaN
  } : "integerValue" in t2 || "doubleValue" in t2 ? {
    timestampValue: {
      seconds: Number.MIN_SAFE_INTEGER
    }
  } : "timestampValue" in t2 ? {
    stringValue: ""
  } : "stringValue" in t2 ? {
    bytesValue: ""
  } : "bytesValue" in t2 ? qt(vt.empty(), xt.empty()) : "referenceValue" in t2 ? {
    geoPointValue: {
      latitude: -90,
      longitude: -180
    }
  } : "geoPointValue" in t2 ? {
    arrayValue: {}
  } : "arrayValue" in t2 ? {
    mapValue: {}
  } : "mapValue" in t2 ? Nt : L2();
}
function Xt(t2, e) {
  return t2 === void 0 ? e : e === void 0 || $t(t2, e) > 0 ? t2 : e;
}
function Zt(t2, e) {
  return t2 === void 0 ? e : e === void 0 || $t(t2, e) < 0 ? t2 : e;
}
var te = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new te({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !Wt(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = zt(e);
  }
  setAll(t2) {
    let e = mt.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = zt(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    Wt(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return Ot(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      Wt(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    lt(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new te(zt(this.value));
  }
};
function ee(t2) {
  const e = [];
  return lt(t2.fields, (t3, n) => {
    const s = new mt([t3]);
    if (Wt(n)) {
      const t4 = ee(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new gt(e);
}
var ne = class {
  constructor(t2, e, n, s, i, r) {
    this.key = t2, this.documentType = e, this.version = n, this.readTime = s, this.data = i, this.documentState = r;
  }
  static newInvalidDocument(t2) {
    return new ne(t2, 0, ct.min(), ct.min(), te.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new ne(t2, 1, e, ct.min(), n, 0);
  }
  static newNoDocument(t2, e) {
    return new ne(t2, 2, e, ct.min(), te.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new ne(t2, 3, e, ct.min(), te.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = te.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = te.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  setReadTime(t2) {
    return this.readTime = t2, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof ne && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  mutableCopy() {
    return new ne(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var se = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.collectionGroup = e, this.fields = n, this.indexState = s;
  }
};
function ie(t2) {
  return t2.fields.find((t3) => t3.kind === 2);
}
function re(t2) {
  return t2.fields.filter((t3) => t3.kind !== 2);
}
se.UNKNOWN_ID = -1;
var oe = class {
  constructor(t2, e) {
    this.fieldPath = t2, this.kind = e;
  }
};
var ue = class {
  constructor(t2, e) {
    this.sequenceNumber = t2, this.offset = e;
  }
  static empty() {
    return new ue(0, he.min());
  }
};
function ae(t2, e) {
  const n = t2.toTimestamp().seconds, s = t2.toTimestamp().nanoseconds + 1, i = ct.fromTimestamp(s === 1e9 ? new at(n + 1, 0) : new at(n, s));
  return new he(i, xt.empty(), e);
}
function ce(t2) {
  return new he(t2.readTime, t2.key, -1);
}
var he = class {
  constructor(t2, e, n) {
    this.readTime = t2, this.documentKey = e, this.largestBatchId = n;
  }
  static min() {
    return new he(ct.min(), xt.empty(), -1);
  }
  static max() {
    return new he(ct.max(), xt.empty(), -1);
  }
};
function le(t2, e) {
  let n = t2.readTime.compareTo(e.readTime);
  return n !== 0 ? n : (n = xt.comparator(t2.documentKey, e.documentKey), n !== 0 ? n : rt(t2.largestBatchId, e.largestBatchId));
}
var fe = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.P = null;
  }
};
function de(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new fe(t2, e, n, s, i, r, o);
}
function _e(t2) {
  const e = K2(t2);
  if (e.P === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => {
      return (e2 = t4).field.canonicalString() + e2.op.toString() + Lt(e2.value);
      var e2;
    }).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), St(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += e.startAt.inclusive ? "b:" : "a:", t3 += e.startAt.position.map((t4) => Lt(t4)).join(",")), e.endAt && (t3 += "|ub:", t3 += e.endAt.inclusive ? "a:" : "b:", t3 += e.endAt.position.map((t4) => Lt(t4)).join(",")), e.P = t3;
  }
  return e.P;
}
function we(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${Lt(e2.value)}`;
    var e2;
  }).join(", ")}]`), St(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: ", e += t2.startAt.inclusive ? "b:" : "a:", e += t2.startAt.position.map((t3) => Lt(t3)).join(",")), t2.endAt && (e += ", endAt: ", e += t2.endAt.inclusive ? "a:" : "b:", e += t2.endAt.position.map((t3) => Lt(t3)).join(",")), `Target(${e})`;
}
function me(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!xe(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !Ot(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!ke(t2.startAt, e.startAt) && ke(t2.endAt, e.endAt)));
}
function ge(t2) {
  return xt.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
function ye(t2, e) {
  return t2.filters.filter((t3) => t3 instanceof Te && t3.field.isEqual(e));
}
function pe(t2, e, n) {
  let s, i = true;
  for (const n2 of ye(t2, e)) {
    let t3, e2 = true;
    switch (n2.op) {
      case "<":
      case "<=":
        t3 = Jt(n2.value);
        break;
      case "==":
      case "in":
      case ">=":
        t3 = n2.value;
        break;
      case ">":
        t3 = n2.value, e2 = false;
        break;
      case "!=":
      case "not-in":
        t3 = kt;
    }
    Xt(s, t3) === t3 && (s = t3, i = e2);
  }
  if (n !== null)
    for (let r = 0; r < t2.orderBy.length; ++r) {
      if (t2.orderBy[r].field.isEqual(e)) {
        const t3 = n.position[r];
        Xt(s, t3) === t3 && (s = t3, i = n.inclusive);
        break;
      }
    }
  return {
    value: s,
    inclusive: i
  };
}
function Ie(t2, e, n) {
  let s, i = true;
  for (const n2 of ye(t2, e)) {
    let t3, e2 = true;
    switch (n2.op) {
      case ">=":
      case ">":
        t3 = Yt(n2.value), e2 = false;
        break;
      case "==":
      case "in":
      case "<=":
        t3 = n2.value;
        break;
      case "<":
        t3 = n2.value, e2 = false;
        break;
      case "!=":
      case "not-in":
        t3 = Nt;
    }
    Zt(s, t3) === t3 && (s = t3, i = e2);
  }
  if (n !== null)
    for (let r = 0; r < t2.orderBy.length; ++r) {
      if (t2.orderBy[r].field.isEqual(e)) {
        const t3 = n.position[r];
        Zt(s, t3) === t3 && (s = t3, i = n.inclusive);
        break;
      }
    }
  return {
    value: s,
    inclusive: i
  };
}
var Te = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.V(t2, e, n) : new Ee(t2, e, n) : e === "array-contains" ? new be(t2, n) : e === "in" ? new Ve(t2, n) : e === "not-in" ? new ve(t2, n) : e === "array-contains-any" ? new Se(t2, n) : new Te(t2, e, n);
  }
  static V(t2, e, n) {
    return e === "in" ? new Ae(t2, n) : new Re(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.v($t(e, this.value)) : e !== null && Mt(this.value) === Mt(e) && this.v($t(e, this.value));
  }
  v(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return L2();
    }
  }
  S() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
var Ee = class extends Te {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = xt.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = xt.comparator(t2.key, this.key);
    return this.v(e);
  }
};
var Ae = class extends Te {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = Pe("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var Re = class extends Te {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = Pe("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function Pe(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => xt.fromName(t3.referenceValue));
}
var be = class extends Te {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return Gt(e) && Ft(e.arrayValue, this.value);
  }
};
var Ve = class extends Te {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && Ft(this.value.arrayValue, e);
  }
};
var ve = class extends Te {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (Ft(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !Ft(this.value.arrayValue, e);
  }
};
var Se = class extends Te {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!Gt(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => Ft(this.value.arrayValue, t3));
  }
};
var De = class {
  constructor(t2, e) {
    this.position = t2, this.inclusive = e;
  }
};
var Ce = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function xe(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function Ne(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = xt.comparator(xt.fromName(o.referenceValue), n.key);
    else {
      s = $t(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return s;
}
function ke(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.inclusive !== e.inclusive || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!Ot(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var Me = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, u = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = u, this.D = null, this.C = null, this.startAt, this.endAt;
  }
};
function Oe(t2, e, n, s, i, r, o, u) {
  return new Me(t2, e, n, s, i, r, o, u);
}
function Fe(t2) {
  return new Me(t2);
}
function $e(t2) {
  return !St(t2.limit) && t2.limitType === "F";
}
function Be(t2) {
  return !St(t2.limit) && t2.limitType === "L";
}
function Le(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function Ue(t2) {
  for (const e of t2.filters)
    if (e.S())
      return e.field;
  return null;
}
function qe(t2) {
  return t2.collectionGroup !== null;
}
function Ke(t2) {
  const e = K2(t2);
  if (e.D === null) {
    e.D = [];
    const t3 = Ue(e), n = Le(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.D.push(new Ce(t3)), e.D.push(new Ce(mt.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.D.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.D.push(new Ce(mt.keyField(), t5));
      }
    }
  }
  return e.D;
}
function Ge(t2) {
  const e = K2(t2);
  if (!e.C)
    if (e.limitType === "F")
      e.C = de(e.path, e.collectionGroup, Ke(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of Ke(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new Ce(n2.field, e2));
      }
      const n = e.endAt ? new De(e.endAt.position, !e.endAt.inclusive) : null, s = e.startAt ? new De(e.startAt.position, !e.startAt.inclusive) : null;
      e.C = de(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.C;
}
function Qe(t2, e, n) {
  return new Me(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function je(t2, e) {
  return me(Ge(t2), Ge(e)) && t2.limitType === e.limitType;
}
function We(t2) {
  return `${_e(Ge(t2))}|lt:${t2.limitType}`;
}
function ze(t2) {
  return `Query(target=${we(Ge(t2))}; limitType=${t2.limitType})`;
}
function He(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : xt.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !function(t4, e3, n) {
      const s = Ne(t4, e3, n);
      return t4.inclusive ? s <= 0 : s < 0;
    }(t3.startAt, Ke(t3), e2))
      return false;
    if (t3.endAt && !function(t4, e3, n) {
      const s = Ne(t4, e3, n);
      return t4.inclusive ? s >= 0 : s > 0;
    }(t3.endAt, Ke(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function Je(t2) {
  return t2.collectionGroup || (t2.path.length % 2 == 1 ? t2.path.lastSegment() : t2.path.get(t2.path.length - 2));
}
function Ye(t2) {
  return (e, n) => {
    let s = false;
    for (const i of Ke(t2)) {
      const t3 = Xe(i, e, n);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function Xe(t2, e, n) {
  const s = t2.field.isKeyField() ? xt.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return s2 !== null && i !== null ? $t(s2, i) : L2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return L2();
  }
}
function Ze(t2, e) {
  if (t2.N) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: Dt(e) ? "-0" : e
  };
}
function tn(t2) {
  return {
    integerValue: "" + t2
  };
}
function en(t2, e) {
  return Ct(e) ? tn(e) : Ze(t2, e);
}
var nn = class {
  constructor() {
    this._ = void 0;
  }
};
function sn(t2, e, n) {
  return t2 instanceof un ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof an ? cn(t2, e) : t2 instanceof hn ? ln(t2, e) : function(t3, e2) {
    const n2 = on(t3, e2), s = dn(n2) + dn(t3.k);
    return Kt(n2) && Kt(t3.k) ? tn(s) : Ze(t3.M, s);
  }(t2, e);
}
function rn(t2, e, n) {
  return t2 instanceof an ? cn(t2, e) : t2 instanceof hn ? ln(t2, e) : n;
}
function on(t2, e) {
  return t2 instanceof fn ? Kt(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var un = class extends nn {
};
var an = class extends nn {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function cn(t2, e) {
  const n = _n(e);
  for (const e2 of t2.elements)
    n.some((t3) => Ot(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var hn = class extends nn {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function ln(t2, e) {
  let n = _n(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !Ot(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var fn = class extends nn {
  constructor(t2, e) {
    super(), this.M = t2, this.k = e;
  }
};
function dn(t2) {
  return Et(t2.integerValue || t2.doubleValue);
}
function _n(t2) {
  return Gt(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var wn = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function mn(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof an && e2 instanceof an || t3 instanceof hn && e2 instanceof hn ? ot(t3.elements, e2.elements, Ot) : t3 instanceof fn && e2 instanceof fn ? Ot(t3.k, e2.k) : t3 instanceof un && e2 instanceof un;
  }(t2.transform, e.transform);
}
var gn = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var yn = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new yn();
  }
  static exists(t2) {
    return new yn(void 0, t2);
  }
  static updateTime(t2) {
    return new yn(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function pn(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
var In = class {
};
function Tn(t2, e, n) {
  t2 instanceof bn ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = Sn(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof Vn ? function(t3, e2, n2) {
    if (!pn(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = Sn(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(vn(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function En(t2, e, n) {
  t2 instanceof bn ? function(t3, e2, n2) {
    if (!pn(t3.precondition, e2))
      return;
    const s = t3.value.clone(), i = Dn(t3.fieldTransforms, n2, e2);
    s.setAll(i), e2.convertToFoundDocument(Pn(e2), s).setHasLocalMutations();
  }(t2, e, n) : t2 instanceof Vn ? function(t3, e2, n2) {
    if (!pn(t3.precondition, e2))
      return;
    const s = Dn(t3.fieldTransforms, n2, e2), i = e2.data;
    i.setAll(vn(t3)), i.setAll(s), e2.convertToFoundDocument(Pn(e2), i).setHasLocalMutations();
  }(t2, e, n) : function(t3, e2) {
    pn(t3.precondition, e2) && e2.convertToNoDocument(ct.min());
  }(t2, e);
}
function An(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = on(s.transform, t3 || null);
    i != null && (n == null && (n = te.empty()), n.set(s.field, i));
  }
  return n || null;
}
function Rn(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && ot(t3, e2, (t4, e3) => mn(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function Pn(t2) {
  return t2.isFoundDocument() ? t2.version : ct.min();
}
var bn = class extends In {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
};
var Vn = class extends In {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
};
function vn(t2) {
  const e = /* @__PURE__ */ new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function Sn(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  U2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, u = e.data.field(r.field);
    s.set(r.field, rn(o, u, n[i]));
  }
  return s;
}
function Dn(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, sn(t3, r, e));
  }
  return s;
}
var Cn = class extends In {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
};
var xn = class extends In {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
};
var Nn = class {
  constructor(t2) {
    this.count = t2;
  }
};
var kn;
var Mn;
function On(t2) {
  switch (t2) {
    default:
      return L2();
    case G.CANCELLED:
    case G.UNKNOWN:
    case G.DEADLINE_EXCEEDED:
    case G.RESOURCE_EXHAUSTED:
    case G.INTERNAL:
    case G.UNAVAILABLE:
    case G.UNAUTHENTICATED:
      return false;
    case G.INVALID_ARGUMENT:
    case G.NOT_FOUND:
    case G.ALREADY_EXISTS:
    case G.PERMISSION_DENIED:
    case G.FAILED_PRECONDITION:
    case G.ABORTED:
    case G.OUT_OF_RANGE:
    case G.UNIMPLEMENTED:
    case G.DATA_LOSS:
      return true;
  }
}
function Fn(t2) {
  if (t2 === void 0)
    return F2("GRPC error has no .code"), G.UNKNOWN;
  switch (t2) {
    case kn.OK:
      return G.OK;
    case kn.CANCELLED:
      return G.CANCELLED;
    case kn.UNKNOWN:
      return G.UNKNOWN;
    case kn.DEADLINE_EXCEEDED:
      return G.DEADLINE_EXCEEDED;
    case kn.RESOURCE_EXHAUSTED:
      return G.RESOURCE_EXHAUSTED;
    case kn.INTERNAL:
      return G.INTERNAL;
    case kn.UNAVAILABLE:
      return G.UNAVAILABLE;
    case kn.UNAUTHENTICATED:
      return G.UNAUTHENTICATED;
    case kn.INVALID_ARGUMENT:
      return G.INVALID_ARGUMENT;
    case kn.NOT_FOUND:
      return G.NOT_FOUND;
    case kn.ALREADY_EXISTS:
      return G.ALREADY_EXISTS;
    case kn.PERMISSION_DENIED:
      return G.PERMISSION_DENIED;
    case kn.FAILED_PRECONDITION:
      return G.FAILED_PRECONDITION;
    case kn.ABORTED:
      return G.ABORTED;
    case kn.OUT_OF_RANGE:
      return G.OUT_OF_RANGE;
    case kn.UNIMPLEMENTED:
      return G.UNIMPLEMENTED;
    case kn.DATA_LOSS:
      return G.DATA_LOSS;
    default:
      return L2();
  }
}
(Mn = kn || (kn = {}))[Mn.OK = 0] = "OK", Mn[Mn.CANCELLED = 1] = "CANCELLED", Mn[Mn.UNKNOWN = 2] = "UNKNOWN", Mn[Mn.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Mn[Mn.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Mn[Mn.NOT_FOUND = 5] = "NOT_FOUND", Mn[Mn.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Mn[Mn.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Mn[Mn.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Mn[Mn.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Mn[Mn.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Mn[Mn.ABORTED = 10] = "ABORTED", Mn[Mn.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Mn[Mn.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Mn[Mn.INTERNAL = 13] = "INTERNAL", Mn[Mn.UNAVAILABLE = 14] = "UNAVAILABLE", Mn[Mn.DATA_LOSS = 15] = "DATA_LOSS";
var $n = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {}, this.innerSize = 0;
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n !== void 0) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (s === void 0)
      return this.inner[n] = [[t2, e]], void this.innerSize++;
    for (let n2 = 0; n2 < s.length; n2++)
      if (this.equalsFn(s[n2][0], t2))
        return void (s[n2] = [t2, e]);
    s.push([t2, e]), this.innerSize++;
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n === void 0)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return n.length === 1 ? delete this.inner[e] : n.splice(s, 1), this.innerSize--, true;
    return false;
  }
  forEach(t2) {
    lt(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return ft(this.inner);
  }
  size() {
    return this.innerSize;
  }
};
var Bn = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || Un.EMPTY;
  }
  insert(t2, e) {
    return new Bn(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, Un.BLACK, null, null));
  }
  remove(t2) {
    return new Bn(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, Un.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (n === 0)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (s === 0)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new Ln(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new Ln(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new Ln(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new Ln(this.root, t2, this.comparator, true);
  }
};
var Ln = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, e && s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var Un = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = n != null ? n : Un.RED, this.left = s != null ? s : Un.EMPTY, this.right = i != null ? i : Un.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new Un(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return Un.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return Un.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, Un.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, Un.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw L2();
    if (this.right.isRed())
      throw L2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw L2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
Un.EMPTY = null, Un.RED = true, Un.BLACK = false;
Un.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw L2();
  }
  get value() {
    throw L2();
  }
  get color() {
    throw L2();
  }
  get left() {
    throw L2();
  }
  get right() {
    throw L2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new Un(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var qn = class {
  constructor(t2) {
    this.comparator = t2, this.data = new Bn(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new Kn(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new Kn(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof qn))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new qn(this.comparator);
    return e.data = t2, e;
  }
};
var Kn = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
function Gn(t2) {
  return t2.hasNext() ? t2.getNext() : void 0;
}
var Qn = new Bn(xt.comparator);
function jn() {
  return Qn;
}
var Wn = new Bn(xt.comparator);
function zn() {
  return Wn;
}
function Hn() {
  return new $n((t2) => t2.toString(), (t2, e) => t2.isEqual(e));
}
var Jn = new Bn(xt.comparator);
var Yn = new qn(xt.comparator);
function Xn(...t2) {
  let e = Yn;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var Zn = new qn(rt);
function ts() {
  return Zn;
}
var es = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return n.set(t2, ns.createSynthesizedTargetChangeForCurrentChange(t2, e)), new es(ct.min(), n, ts(), jn(), Xn());
  }
};
var ns = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new ns(pt.EMPTY_BYTE_STRING, e, Xn(), Xn(), Xn());
  }
};
var ss = class {
  constructor(t2, e, n, s) {
    this.O = t2, this.removedTargetIds = e, this.key = n, this.F = s;
  }
};
var is = class {
  constructor(t2, e) {
    this.targetId = t2, this.$ = e;
  }
};
var rs = class {
  constructor(t2, e, n = pt.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var os = class {
  constructor() {
    this.B = 0, this.L = cs(), this.U = pt.EMPTY_BYTE_STRING, this.q = false, this.K = true;
  }
  get current() {
    return this.q;
  }
  get resumeToken() {
    return this.U;
  }
  get G() {
    return this.B !== 0;
  }
  get j() {
    return this.K;
  }
  W(t2) {
    t2.approximateByteSize() > 0 && (this.K = true, this.U = t2);
  }
  H() {
    let t2 = Xn(), e = Xn(), n = Xn();
    return this.L.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          L2();
      }
    }), new ns(this.U, this.q, t2, e, n);
  }
  J() {
    this.K = false, this.L = cs();
  }
  Y(t2, e) {
    this.K = true, this.L = this.L.insert(t2, e);
  }
  X(t2) {
    this.K = true, this.L = this.L.remove(t2);
  }
  Z() {
    this.B += 1;
  }
  tt() {
    this.B -= 1;
  }
  et() {
    this.K = true, this.q = true;
  }
};
var us = class {
  constructor(t2) {
    this.nt = t2, this.st = /* @__PURE__ */ new Map(), this.it = jn(), this.rt = as(), this.ot = new qn(rt);
  }
  ut(t2) {
    for (const e of t2.O)
      t2.F && t2.F.isFoundDocument() ? this.at(e, t2.F) : this.ct(e, t2.key, t2.F);
    for (const e of t2.removedTargetIds)
      this.ct(e, t2.key, t2.F);
  }
  ht(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.lt(e);
      switch (t2.state) {
        case 0:
          this.ft(e) && n.W(t2.resumeToken);
          break;
        case 1:
          n.tt(), n.G || n.J(), n.W(t2.resumeToken);
          break;
        case 2:
          n.tt(), n.G || this.removeTarget(e);
          break;
        case 3:
          this.ft(e) && (n.et(), n.W(t2.resumeToken));
          break;
        case 4:
          this.ft(e) && (this.dt(e), n.W(t2.resumeToken));
          break;
        default:
          L2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.st.forEach((t3, n) => {
      this.ft(n) && e(n);
    });
  }
  _t(t2) {
    const e = t2.targetId, n = t2.$.count, s = this.wt(e);
    if (s) {
      const t3 = s.target;
      if (ge(t3))
        if (n === 0) {
          const n2 = new xt(t3.path);
          this.ct(e, n2, ne.newNoDocument(n2, ct.min()));
        } else
          U2(n === 1);
      else {
        this.gt(e) !== n && (this.dt(e), this.ot = this.ot.add(e));
      }
    }
  }
  yt(t2) {
    const e = /* @__PURE__ */ new Map();
    this.st.forEach((n2, s2) => {
      const i = this.wt(s2);
      if (i) {
        if (n2.current && ge(i.target)) {
          const e2 = new xt(i.target.path);
          this.it.get(e2) !== null || this.It(s2, e2) || this.ct(s2, e2, ne.newNoDocument(e2, t2));
        }
        n2.j && (e.set(s2, n2.H()), n2.J());
      }
    });
    let n = Xn();
    this.rt.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.wt(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    }), this.it.forEach((e2, n2) => n2.setReadTime(t2));
    const s = new es(t2, e, this.ot, this.it, n);
    return this.it = jn(), this.rt = as(), this.ot = new qn(rt), s;
  }
  at(t2, e) {
    if (!this.ft(t2))
      return;
    const n = this.It(t2, e.key) ? 2 : 0;
    this.lt(t2).Y(e.key, n), this.it = this.it.insert(e.key, e), this.rt = this.rt.insert(e.key, this.Tt(e.key).add(t2));
  }
  ct(t2, e, n) {
    if (!this.ft(t2))
      return;
    const s = this.lt(t2);
    this.It(t2, e) ? s.Y(e, 1) : s.X(e), this.rt = this.rt.insert(e, this.Tt(e).delete(t2)), n && (this.it = this.it.insert(e, n));
  }
  removeTarget(t2) {
    this.st.delete(t2);
  }
  gt(t2) {
    const e = this.lt(t2).H();
    return this.nt.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  Z(t2) {
    this.lt(t2).Z();
  }
  lt(t2) {
    let e = this.st.get(t2);
    return e || (e = new os(), this.st.set(t2, e)), e;
  }
  Tt(t2) {
    let e = this.rt.get(t2);
    return e || (e = new qn(rt), this.rt = this.rt.insert(t2, e)), e;
  }
  ft(t2) {
    const e = this.wt(t2) !== null;
    return e || O2("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  wt(t2) {
    const e = this.st.get(t2);
    return e && e.G ? null : this.nt.Et(t2);
  }
  dt(t2) {
    this.st.set(t2, new os());
    this.nt.getRemoteKeysForTarget(t2).forEach((e) => {
      this.ct(t2, e, null);
    });
  }
  It(t2, e) {
    return this.nt.getRemoteKeysForTarget(t2).has(e);
  }
};
function as() {
  return new Bn(xt.comparator);
}
function cs() {
  return new Bn(xt.comparator);
}
var hs = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var ls = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var fs = class {
  constructor(t2, e) {
    this.databaseId = t2, this.N = e;
  }
};
function ds(t2, e) {
  if (t2.N) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function _s(t2, e) {
  return t2.N ? e.toBase64() : e.toUint8Array();
}
function ws(t2, e) {
  return ds(t2, e.toTimestamp());
}
function ms(t2) {
  return U2(!!t2), ct.fromTimestamp(function(t3) {
    const e = Tt(t3);
    return new at(e.seconds, e.nanos);
  }(t2));
}
function gs(t2, e) {
  return function(t3) {
    return new _t(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function ys(t2) {
  const e = _t.fromString(t2);
  return U2(Gs(e)), e;
}
function ps(t2, e) {
  return gs(t2.databaseId, e.path);
}
function Is(t2, e) {
  const n = ys(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new Q2(G.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new Q2(G.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new xt(Rs(n));
}
function Ts(t2, e) {
  return gs(t2.databaseId, e);
}
function Es(t2) {
  const e = ys(t2);
  return e.length === 4 ? _t.emptyPath() : Rs(e);
}
function As(t2) {
  return new _t(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function Rs(t2) {
  return U2(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function Ps(t2, e, n) {
  return {
    name: ps(t2, e),
    fields: n.value.mapValue.fields
  };
}
function bs(t2, e, n) {
  const s = Is(t2, e.name), i = ms(e.updateTime), r = new te({
    mapValue: {
      fields: e.fields
    }
  }), o = ne.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function Vs(t2, e) {
  return "found" in e ? function(t3, e2) {
    U2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = Is(t3, e2.found.name), s = ms(e2.found.updateTime), i = new te({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return ne.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    U2(!!e2.missing), U2(!!e2.readTime);
    const n = Is(t3, e2.missing), s = ms(e2.readTime);
    return ne.newNoDocument(n, s);
  }(t2, e) : L2();
}
function vs(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : L2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.N ? (U2(e2 === void 0 || typeof e2 == "string"), pt.fromBase64String(e2 || "")) : (U2(e2 === void 0 || e2 instanceof Uint8Array), pt.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, u = o && function(t3) {
      const e2 = t3.code === void 0 ? G.UNKNOWN : Fn(t3.code);
      return new Q2(e2, t3.message || "");
    }(o);
    n = new rs(s, i, r, u || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = Is(t2, s.document.name), r = ms(s.document.updateTime), o = new te({
      mapValue: {
        fields: s.document.fields
      }
    }), u = ne.newFoundDocument(i, r, o), a = s.targetIds || [], c = s.removedTargetIds || [];
    n = new ss(a, c, u.key, u);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = Is(t2, s.document), r = s.readTime ? ms(s.readTime) : ct.min(), o = ne.newNoDocument(i, r), u = s.removedTargetIds || [];
    n = new ss([], u, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = Is(t2, s.document), r = s.removedTargetIds || [];
    n = new ss([], r, i, null);
  } else {
    if (!("filter" in e))
      return L2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new Nn(s), r = t3.targetId;
      n = new is(r, i);
    }
  }
  return n;
}
function Ss(t2, e) {
  let n;
  if (e instanceof bn)
    n = {
      update: Ps(t2, e.key, e.value)
    };
  else if (e instanceof Cn)
    n = {
      delete: ps(t2, e.key)
    };
  else if (e instanceof Vn)
    n = {
      update: Ps(t2, e.key, e.data),
      updateMask: Ks(e.fieldMask)
    };
  else {
    if (!(e instanceof xn))
      return L2();
    n = {
      verify: ps(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof un)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof an)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof hn)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof fn)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.k
      };
    throw L2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: ws(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : L2();
  }(t2, e.precondition)), n;
}
function Ds(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? yn.updateTime(ms(t3.updateTime)) : t3.exists !== void 0 ? yn.exists(t3.exists) : yn.none();
  }(e.currentDocument) : yn.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      U2(e3.setToServerValue === "REQUEST_TIME"), n2 = new un();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new an(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new hn(t4);
    } else
      "increment" in e3 ? n2 = new fn(t3, e3.increment) : L2();
    const s2 = mt.fromServerFormat(e3.fieldPath);
    return new wn(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = Is(t2, e.update.name), r = new te({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new gt(e2.map((t5) => mt.fromServerFormat(t5)));
      }(e.updateMask);
      return new Vn(i, r, t3, n, s);
    }
    return new bn(i, r, n, s);
  }
  if (e.delete) {
    const s2 = Is(t2, e.delete);
    return new Cn(s2, n);
  }
  if (e.verify) {
    const s2 = Is(t2, e.verify);
    return new xn(s2, n);
  }
  return L2();
}
function Cs(t2, e) {
  return t2 && t2.length > 0 ? (U2(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? ms(t4.updateTime) : ms(e2);
    return n.isEqual(ct.min()) && (n = ms(e2)), new gn(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function xs(t2, e) {
  return {
    documents: [Ts(t2, e.path)]
  };
}
function Ns(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n.parent = Ts(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = Ts(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (jt(t5.value))
          return {
            unaryFilter: {
              field: Bs(t5.field),
              op: "IS_NAN"
            }
          };
        if (Qt(t5.value))
          return {
            unaryFilter: {
              field: Bs(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (jt(t5.value))
          return {
            unaryFilter: {
              field: Bs(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Qt(t5.value))
          return {
            unaryFilter: {
              field: Bs(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: Bs(t5.field),
          op: $s(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: Bs(t5.field),
        direction: Fs(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.N || St(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  var u;
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = {
    before: (u = e.startAt).inclusive,
    values: u.position
  }), e.endAt && (n.structuredQuery.endAt = function(t3) {
    return {
      before: !t3.inclusive,
      values: t3.position
    };
  }(e.endAt)), n;
}
function ks(t2) {
  let e = Es(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    U2(s === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = Os(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new Ce(Ls(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let u = null;
  n.limit && (u = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, St(e2) ? null : e2;
  }(n.limit));
  let a = null;
  n.startAt && (a = function(t3) {
    const e2 = !!t3.before, n2 = t3.values || [];
    return new De(n2, e2);
  }(n.startAt));
  let c = null;
  return n.endAt && (c = function(t3) {
    const e2 = !t3.before, n2 = t3.values || [];
    return new De(n2, e2);
  }(n.endAt)), Oe(e, i, o, r, u, "F", a, c);
}
function Ms(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return L2();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function Os(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [qs(t2)] : t2.fieldFilter !== void 0 ? [Us(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => Os(t3)).reduce((t3, e) => t3.concat(e)) : L2() : [];
}
function Fs(t2) {
  return hs[t2];
}
function $s(t2) {
  return ls[t2];
}
function Bs(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function Ls(t2) {
  return mt.fromServerFormat(t2.fieldPath);
}
function Us(t2) {
  return Te.create(Ls(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return L2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function qs(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = Ls(t2.unaryFilter.field);
      return Te.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = Ls(t2.unaryFilter.field);
      return Te.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = Ls(t2.unaryFilter.field);
      return Te.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = Ls(t2.unaryFilter.field);
      return Te.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return L2();
  }
}
function Ks(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function Gs(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function Qs(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = Ws(e)), e = js(t2.get(n), e);
  return Ws(e);
}
function js(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function Ws(t2) {
  return t2 + "";
}
function zs(t2) {
  const e = t2.length;
  if (U2(e >= 2), e === 2)
    return U2(t2.charAt(0) === "" && t2.charAt(1) === ""), _t.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && L2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        i.length === 0 ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        L2();
    }
    r = e2 + 2;
  }
  return new _t(s);
}
var Hs = ["userId", "batchId"];
function Js(t2, e) {
  return [t2, Qs(e)];
}
function Ys(t2, e, n) {
  return [t2, Qs(e), n];
}
var Xs = {};
var Zs = ["prefixPath", "collectionGroup", "readTime", "documentId"];
var ti = ["prefixPath", "collectionGroup", "documentId"];
var ei = ["collectionGroup", "readTime", "prefixPath", "documentId"];
var ni = ["canonicalId", "targetId"];
var si = ["targetId", "path"];
var ii = ["path", "targetId"];
var ri = ["collectionId", "parent"];
var oi = ["indexId", "uid"];
var ui = ["uid", "sequenceNumber"];
var ai = ["indexId", "uid", "arrayValue", "directionalValue", "orderedDocumentKey", "documentKey"];
var ci = ["indexId", "uid", "orderedDocumentKey"];
var hi = ["userId", "collectionPath", "documentId"];
var li = ["userId", "collectionPath", "largestBatchId"];
var fi = ["userId", "collectionGroup", "largestBatchId"];
var di = [...[...[...[...["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments"], "clientMetadata"], "remoteDocumentGlobal"], "collectionParents"], "bundles", "namedQueries"];
var _i = [...di, "documentOverlays"];
var wi = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"];
var mi = [...wi, "indexConfiguration", "indexState", "indexEntries"];
var gi = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var yi = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
var pi = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && L2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new pi((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof pi ? e : pi.resolve(e);
    } catch (t3) {
      return pi.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : pi.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : pi.reject(e);
  }
  static resolve(t2) {
    return new pi((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new pi((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new pi((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = pi.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? pi.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
};
var Ii = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.At = new j(), this.transaction.oncomplete = () => {
      this.At.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.At.reject(new Ai(t2, e.error)) : this.At.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = vi(e2.target.error);
      this.At.reject(new Ai(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new Ii(e, t2.transaction(s, n));
    } catch (t3) {
      throw new Ai(e, t3);
    }
  }
  get Rt() {
    return this.At.promise;
  }
  abort(t2) {
    t2 && this.At.reject(t2), this.aborted || (O2("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  Pt() {
    const t2 = this.transaction;
    this.aborted || typeof t2.commit != "function" || t2.commit();
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new Pi(e);
  }
};
var Ti = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.bt = n;
    Ti.Vt(getUA()) === 12.2 && F2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return O2("SimpleDb", "Removing database:", t2), bi(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static vt() {
    if (!isIndexedDBAvailable())
      return false;
    if (Ti.St())
      return true;
    const t2 = getUA(), e = Ti.Vt(t2), n = 0 < e && e < 10, s = Ti.Dt(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static St() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.Ct) === "YES";
  }
  static xt(t2, e) {
    return t2.store(e);
  }
  static Vt(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static Dt(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async Nt(t2) {
    return this.db || (O2("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new Ai(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n(new Q2(G.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : s2.name === "InvalidStateError" ? n(new Q2(G.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new Ai(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        O2("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.bt.kt(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          O2("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.Mt && (this.db.onversionchange = (t3) => this.Mt(t3)), this.db;
  }
  Ot(t2) {
    this.Mt = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = e === "readonly";
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.Nt(t2);
        const e2 = Ii.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).next((t3) => (e2.Pt(), t3)).catch((t3) => (e2.abort(t3), pi.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.Rt, r2;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r < 3;
        if (O2("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var Ei = class {
  constructor(t2) {
    this.Ft = t2, this.$t = false, this.Bt = null;
  }
  get isDone() {
    return this.$t;
  }
  get Lt() {
    return this.Bt;
  }
  set cursor(t2) {
    this.Ft = t2;
  }
  done() {
    this.$t = true;
  }
  Ut(t2) {
    this.Bt = t2;
  }
  delete() {
    return bi(this.Ft.delete());
  }
};
var Ai = class extends Q2 {
  constructor(t2, e) {
    super(G.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function Ri(t2) {
  return t2.name === "IndexedDbTransactionError";
}
var Pi = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return e !== void 0 ? (O2("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : (O2("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), bi(n);
  }
  add(t2) {
    O2("SimpleDb", "ADD", this.store.name, t2, t2);
    return bi(this.store.add(t2));
  }
  get(t2) {
    return bi(this.store.get(t2)).next((e) => (e === void 0 && (e = null), O2("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    O2("SimpleDb", "DELETE", this.store.name, t2);
    return bi(this.store.delete(t2));
  }
  count() {
    O2("SimpleDb", "COUNT", this.store.name);
    return bi(this.store.count());
  }
  qt(t2, e) {
    const n = this.options(t2, e);
    if (n.index || typeof this.store.getAll != "function") {
      const t3 = this.cursor(n), e2 = [];
      return this.Kt(t3, (t4, n2) => {
        e2.push(n2);
      }).next(() => e2);
    }
    {
      const t3 = this.store.getAll(n.range);
      return new pi((e2, n2) => {
        t3.onerror = (t4) => {
          n2(t4.target.error);
        }, t3.onsuccess = (t4) => {
          e2(t4.target.result);
        };
      });
    }
  }
  Gt(t2, e) {
    const n = this.store.getAll(t2, e === null ? void 0 : e);
    return new pi((t3, e2) => {
      n.onerror = (t4) => {
        e2(t4.target.error);
      }, n.onsuccess = (e3) => {
        t3(e3.target.result);
      };
    });
  }
  Qt(t2, e) {
    O2("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.jt = false;
    const s = this.cursor(n);
    return this.Kt(s, (t3, e2, n2) => n2.delete());
  }
  Wt(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.Kt(s, e);
  }
  zt(t2) {
    const e = this.cursor({});
    return new pi((n, s) => {
      e.onerror = (t3) => {
        const e2 = vi(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  Kt(t2, e) {
    const n = [];
    return new pi((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new Ei(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof pi) {
          const t4 = o.catch((t5) => (r.done(), pi.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : r.Lt === null ? i2.continue() : i2.continue(r.Lt);
      };
    }).next(() => pi.waitFor(n));
  }
  options(t2, e) {
    let n;
    return t2 !== void 0 && (typeof t2 == "string" ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.jt ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function bi(t2) {
  return new pi((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = vi(t3.target.error);
      n(e2);
    };
  });
}
var Vi = false;
function vi(t2) {
  const e = Ti.Vt(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new Q2("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return Vi || (Vi = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var Si = class extends yi {
  constructor(t2, e) {
    super(), this.Ht = t2, this.currentSequenceNumber = e;
  }
};
function Di(t2, e) {
  const n = K2(t2);
  return Ti.xt(n.Ht, e);
}
var Ci = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        Tn(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2) {
    for (const e of this.baseMutations)
      e.key.isEqual(t2.key) && En(e, t2, this.localWriteTime);
    for (const e of this.mutations)
      e.key.isEqual(t2.key) && En(e, t2, this.localWriteTime);
  }
  applyToLocalDocumentSet(t2) {
    this.mutations.forEach((e) => {
      const n = t2.get(e.key), s = n;
      this.applyToLocalView(s), n.isValidDocument() || s.convertToNoDocument(ct.min());
    });
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), Xn());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && ot(this.mutations, t2.mutations, (t3, e) => Rn(t3, e)) && ot(this.baseMutations, t2.baseMutations, (t3, e) => Rn(t3, e));
  }
};
var xi = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    U2(t2.mutations.length === n.length);
    let s = Jn;
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new xi(t2, e, n, s);
  }
};
var Ni = class {
  constructor(t2, e) {
    this.largestBatchId = t2, this.mutation = e;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(t2) {
    return t2 !== null && this.mutation === t2.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
};
var ki = class {
  constructor(t2, e, n, s, i = ct.min(), r = ct.min(), o = pt.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new ki(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new ki(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new ki(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var Mi = class {
  constructor(t2) {
    this.Jt = t2;
  }
};
function Oi(t2, e) {
  let n;
  if (e.document)
    n = bs(t2.Jt, e.document, !!e.hasCommittedMutations);
  else if (e.noDocument) {
    const t3 = xt.fromSegments(e.noDocument.path), s = Li(e.noDocument.readTime);
    n = ne.newNoDocument(t3, s), e.hasCommittedMutations && n.setHasCommittedMutations();
  } else {
    if (!e.unknownDocument)
      return L2();
    {
      const t3 = xt.fromSegments(e.unknownDocument.path), s = Li(e.unknownDocument.version);
      n = ne.newUnknownDocument(t3, s);
    }
  }
  return e.readTime && n.setReadTime(function(t3) {
    const e2 = new at(t3[0], t3[1]);
    return ct.fromTimestamp(e2);
  }(e.readTime)), n;
}
function Fi(t2, e) {
  const n = e.key, s = {
    prefixPath: n.getCollectionPath().popLast().toArray(),
    collectionGroup: n.collectionGroup,
    documentId: n.path.lastSegment(),
    readTime: $i(e.readTime),
    hasCommittedMutations: e.hasCommittedMutations
  };
  if (e.isFoundDocument())
    s.document = function(t3, e2) {
      return {
        name: ps(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: ds(t3, e2.version.toTimestamp())
      };
    }(t2.Jt, e);
  else if (e.isNoDocument())
    s.noDocument = {
      path: n.path.toArray(),
      readTime: Bi(e.version)
    };
  else {
    if (!e.isUnknownDocument())
      return L2();
    s.unknownDocument = {
      path: n.path.toArray(),
      version: Bi(e.version)
    };
  }
  return s;
}
function $i(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function Bi(t2) {
  const e = t2.toTimestamp();
  return {
    seconds: e.seconds,
    nanoseconds: e.nanoseconds
  };
}
function Li(t2) {
  const e = new at(t2.seconds, t2.nanoseconds);
  return ct.fromTimestamp(e);
}
function Ui(t2, e) {
  const n = (e.baseMutations || []).map((e2) => Ds(t2.Jt, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => Ds(t2.Jt, e2)), i = at.fromMillis(e.localWriteTimeMs);
  return new Ci(e.batchId, i, n, s);
}
function qi(t2) {
  const e = Li(t2.readTime), n = t2.lastLimboFreeSnapshotVersion !== void 0 ? Li(t2.lastLimboFreeSnapshotVersion) : ct.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (U2((i = t2.query).documents.length === 1), s = Ge(Fe(Es(i.documents[0])))) : s = function(t3) {
    return Ge(ks(t3));
  }(t2.query), new ki(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, pt.fromBase64String(t2.resumeToken));
}
function Ki(t2, e) {
  const n = Bi(e.snapshotVersion), s = Bi(e.lastLimboFreeSnapshotVersion);
  let i;
  i = ge(e.target) ? xs(t2.Jt, e.target) : Ns(t2.Jt, e.target);
  const r = e.resumeToken.toBase64();
  return {
    targetId: e.targetId,
    canonicalId: _e(e.target),
    readTime: n,
    resumeToken: r,
    lastListenSequenceNumber: e.sequenceNumber,
    lastLimboFreeSnapshotVersion: s,
    query: i
  };
}
function Gi(t2) {
  const e = ks({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? Qe(e, e.limit, "L") : e;
}
function Qi(t2, e) {
  return new Ni(e.largestBatchId, Ds(t2.Jt, e.overlayMutation));
}
function ji(t2, e) {
  const n = e.path.lastSegment();
  return [t2, Qs(e.path.popLast()), n];
}
var Wi = class {
  getBundleMetadata(t2, e) {
    return zi(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: Li(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return zi(t2).put({
      bundleId: (n = e).id,
      createTime: Bi(ms(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return Hi(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: Gi(e2.bundledQuery),
          readTime: Li(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return Hi(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: Bi(ms(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function zi(t2) {
  return Di(t2, "bundles");
}
function Hi(t2) {
  return Di(t2, "namedQueries");
}
var Ji = class {
  constructor(t2, e) {
    this.M = t2, this.userId = e;
  }
  static Yt(t2, e) {
    const n = e.uid || "";
    return new Ji(t2, n);
  }
  getOverlay(t2, e) {
    return Yi(t2).get(ji(this.userId, e)).next((t3) => t3 ? Qi(this.M, t3) : null);
  }
  saveOverlays(t2, e, n) {
    const s = [];
    return n.forEach((n2, i) => {
      const r = new Ni(e, i);
      s.push(this.Xt(t2, r));
    }), pi.waitFor(s);
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = /* @__PURE__ */ new Set();
    e.forEach((t3) => s.add(Qs(t3.getCollectionPath())));
    const i = [];
    return s.forEach((e2) => {
      const s2 = IDBKeyRange.bound([this.userId, e2, n], [this.userId, e2, n + 1], false, true);
      i.push(Yi(t2).Qt("collectionPathOverlayIndex", s2));
    }), pi.waitFor(i);
  }
  getOverlaysForCollection(t2, e, n) {
    const s = Hn(), i = Qs(e), r = IDBKeyRange.bound([this.userId, i, n], [this.userId, i, Number.POSITIVE_INFINITY], true);
    return Yi(t2).qt("collectionPathOverlayIndex", r).next((t3) => {
      for (const e2 of t3) {
        const t4 = Qi(this.M, e2);
        s.set(t4.getKey(), t4);
      }
      return s;
    });
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    const i = Hn();
    let r;
    const o = IDBKeyRange.bound([this.userId, e, n], [this.userId, e, Number.POSITIVE_INFINITY], true);
    return Yi(t2).Wt({
      index: "collectionGroupOverlayIndex",
      range: o
    }, (t3, e2, n2) => {
      const o2 = Qi(this.M, e2);
      i.size() < s || o2.largestBatchId === r ? (i.set(o2.getKey(), o2), r = o2.largestBatchId) : n2.done();
    }).next(() => i);
  }
  Xt(t2, e) {
    return Yi(t2).put(function(t3, e2, n) {
      const [s, i, r] = ji(e2, n.mutation.key);
      return {
        userId: e2,
        collectionPath: i,
        documentId: r,
        collectionGroup: n.mutation.key.getCollectionGroup(),
        largestBatchId: n.largestBatchId,
        overlayMutation: Ss(t3.Jt, n.mutation)
      };
    }(this.M, this.userId, e));
  }
};
function Yi(t2) {
  return Di(t2, "documentOverlays");
}
var Xi = class {
  constructor() {
  }
  Zt(t2, e) {
    this.te(t2, e), e.ee();
  }
  te(t2, e) {
    if ("nullValue" in t2)
      this.ne(e, 5);
    else if ("booleanValue" in t2)
      this.ne(e, 10), e.se(t2.booleanValue ? 1 : 0);
    else if ("integerValue" in t2)
      this.ne(e, 15), e.se(Et(t2.integerValue));
    else if ("doubleValue" in t2) {
      const n = Et(t2.doubleValue);
      isNaN(n) ? this.ne(e, 13) : (this.ne(e, 15), Dt(n) ? e.se(0) : e.se(n));
    } else if ("timestampValue" in t2) {
      const n = t2.timestampValue;
      this.ne(e, 20), typeof n == "string" ? e.ie(n) : (e.ie(`${n.seconds || ""}`), e.se(n.nanos || 0));
    } else if ("stringValue" in t2)
      this.re(t2.stringValue, e), this.oe(e);
    else if ("bytesValue" in t2)
      this.ne(e, 30), e.ue(At(t2.bytesValue)), this.oe(e);
    else if ("referenceValue" in t2)
      this.ae(t2.referenceValue, e);
    else if ("geoPointValue" in t2) {
      const n = t2.geoPointValue;
      this.ne(e, 45), e.se(n.latitude || 0), e.se(n.longitude || 0);
    } else
      "mapValue" in t2 ? Ht(t2) ? this.ne(e, Number.MAX_SAFE_INTEGER) : (this.ce(t2.mapValue, e), this.oe(e)) : "arrayValue" in t2 ? (this.he(t2.arrayValue, e), this.oe(e)) : L2();
  }
  re(t2, e) {
    this.ne(e, 25), this.le(t2, e);
  }
  le(t2, e) {
    e.ie(t2);
  }
  ce(t2, e) {
    const n = t2.fields || {};
    this.ne(e, 55);
    for (const t3 of Object.keys(n))
      this.re(t3, e), this.te(n[t3], e);
  }
  he(t2, e) {
    const n = t2.values || [];
    this.ne(e, 50);
    for (const t3 of n)
      this.te(t3, e);
  }
  ae(t2, e) {
    this.ne(e, 37);
    xt.fromName(t2).path.forEach((t3) => {
      this.ne(e, 60), this.le(t3, e);
    });
  }
  ne(t2, e) {
    t2.se(e);
  }
  oe(t2) {
    t2.se(2);
  }
};
Xi.fe = new Xi();
function Zi(t2) {
  if (t2 === 0)
    return 8;
  let e = 0;
  return t2 >> 4 == 0 && (e += 4, t2 <<= 4), t2 >> 6 == 0 && (e += 2, t2 <<= 2), t2 >> 7 == 0 && (e += 1), e;
}
function tr(t2) {
  const e = 64 - function(t3) {
    let e2 = 0;
    for (let n = 0; n < 8; ++n) {
      const s = Zi(255 & t3[n]);
      if (e2 += s, s !== 8)
        break;
    }
    return e2;
  }(t2);
  return Math.ceil(e / 8);
}
var er = class {
  constructor() {
    this.buffer = new Uint8Array(1024), this.position = 0;
  }
  de(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this._e(n.value), n = e.next();
    this.we();
  }
  me(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.ge(n.value), n = e.next();
    this.ye();
  }
  pe(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this._e(t3);
      else if (t3 < 2048)
        this._e(960 | t3 >>> 6), this._e(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this._e(480 | t3 >>> 12), this._e(128 | 63 & t3 >>> 6), this._e(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this._e(240 | t4 >>> 18), this._e(128 | 63 & t4 >>> 12), this._e(128 | 63 & t4 >>> 6), this._e(128 | 63 & t4);
      }
    }
    this.we();
  }
  Ie(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this.ge(t3);
      else if (t3 < 2048)
        this.ge(960 | t3 >>> 6), this.ge(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.ge(480 | t3 >>> 12), this.ge(128 | 63 & t3 >>> 6), this.ge(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this.ge(240 | t4 >>> 18), this.ge(128 | 63 & t4 >>> 12), this.ge(128 | 63 & t4 >>> 6), this.ge(128 | 63 & t4);
      }
    }
    this.ye();
  }
  Te(t2) {
    const e = this.Ee(t2), n = tr(e);
    this.Ae(1 + n), this.buffer[this.position++] = 255 & n;
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = 255 & e[t3];
  }
  Re(t2) {
    const e = this.Ee(t2), n = tr(e);
    this.Ae(1 + n), this.buffer[this.position++] = ~(255 & n);
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = ~(255 & e[t3]);
  }
  Pe() {
    this.be(255), this.be(255);
  }
  Ve() {
    this.ve(255), this.ve(255);
  }
  reset() {
    this.position = 0;
  }
  seed(t2) {
    this.Ae(t2.length), this.buffer.set(t2, this.position), this.position += t2.length;
  }
  Se() {
    return this.buffer.slice(0, this.position);
  }
  Ee(t2) {
    const e = function(t3) {
      const e2 = new DataView(new ArrayBuffer(8));
      return e2.setFloat64(0, t3, false), new Uint8Array(e2.buffer);
    }(t2), n = (128 & e[0]) != 0;
    e[0] ^= n ? 255 : 128;
    for (let t3 = 1; t3 < e.length; ++t3)
      e[t3] ^= n ? 255 : 0;
    return e;
  }
  _e(t2) {
    const e = 255 & t2;
    e === 0 ? (this.be(0), this.be(255)) : e === 255 ? (this.be(255), this.be(0)) : this.be(e);
  }
  ge(t2) {
    const e = 255 & t2;
    e === 0 ? (this.ve(0), this.ve(255)) : e === 255 ? (this.ve(255), this.ve(0)) : this.ve(t2);
  }
  we() {
    this.be(0), this.be(1);
  }
  ye() {
    this.ve(0), this.ve(1);
  }
  be(t2) {
    this.Ae(1), this.buffer[this.position++] = t2;
  }
  ve(t2) {
    this.Ae(1), this.buffer[this.position++] = ~t2;
  }
  Ae(t2) {
    const e = t2 + this.position;
    if (e <= this.buffer.length)
      return;
    let n = 2 * this.buffer.length;
    n < e && (n = e);
    const s = new Uint8Array(n);
    s.set(this.buffer), this.buffer = s;
  }
};
var nr = class {
  constructor(t2) {
    this.De = t2;
  }
  ue(t2) {
    this.De.de(t2);
  }
  ie(t2) {
    this.De.pe(t2);
  }
  se(t2) {
    this.De.Te(t2);
  }
  ee() {
    this.De.Pe();
  }
};
var sr = class {
  constructor(t2) {
    this.De = t2;
  }
  ue(t2) {
    this.De.me(t2);
  }
  ie(t2) {
    this.De.Ie(t2);
  }
  se(t2) {
    this.De.Re(t2);
  }
  ee() {
    this.De.Ve();
  }
};
var ir = class {
  constructor() {
    this.De = new er(), this.Ce = new nr(this.De), this.xe = new sr(this.De);
  }
  seed(t2) {
    this.De.seed(t2);
  }
  Ne(t2) {
    return t2 === 0 ? this.Ce : this.xe;
  }
  Se() {
    return this.De.Se();
  }
  reset() {
    this.De.reset();
  }
};
var rr = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.documentKey = e, this.arrayValue = n, this.directionalValue = s;
  }
  ke() {
    const t2 = this.directionalValue.length, e = t2 === 0 || this.directionalValue[t2 - 1] === 255 ? t2 + 1 : t2, n = new Uint8Array(e);
    return n.set(this.directionalValue, 0), e !== t2 ? n.set([0], this.directionalValue.length) : ++n[n.length - 1], new rr(this.indexId, this.documentKey, this.arrayValue, n);
  }
};
function or(t2, e) {
  let n = t2.indexId - e.indexId;
  return n !== 0 ? n : (n = ur(t2.arrayValue, e.arrayValue), n !== 0 ? n : (n = ur(t2.directionalValue, e.directionalValue), n !== 0 ? n : xt.comparator(t2.documentKey, e.documentKey)));
}
function ur(t2, e) {
  for (let n = 0; n < t2.length && n < e.length; ++n) {
    const s = t2[n] - e[n];
    if (s !== 0)
      return s;
  }
  return t2.length - e.length;
}
var ar = class {
  constructor(t2) {
    this.collectionId = t2.collectionGroup != null ? t2.collectionGroup : t2.path.lastSegment(), this.Me = t2.orderBy, this.Oe = [];
    for (const e of t2.filters) {
      const t3 = e;
      t3.S() ? this.Fe = t3 : this.Oe.push(t3);
    }
  }
  $e(t2) {
    const e = ie(t2);
    if (e !== void 0 && !this.Be(e))
      return false;
    const n = re(t2);
    let s = 0, i = 0;
    for (; s < n.length && this.Be(n[s]); ++s)
      ;
    if (s === n.length)
      return true;
    if (this.Fe !== void 0) {
      const t3 = n[s];
      if (!this.Le(this.Fe, t3) || !this.Ue(this.Me[i++], t3))
        return false;
      ++s;
    }
    for (; s < n.length; ++s) {
      const t3 = n[s];
      if (i >= this.Me.length || !this.Ue(this.Me[i++], t3))
        return false;
    }
    return true;
  }
  Be(t2) {
    for (const e of this.Oe)
      if (this.Le(e, t2))
        return true;
    return false;
  }
  Le(t2, e) {
    if (t2 === void 0 || !t2.field.isEqual(e.fieldPath))
      return false;
    const n = t2.op === "array-contains" || t2.op === "array-contains-any";
    return e.kind === 2 === n;
  }
  Ue(t2, e) {
    return !!t2.field.isEqual(e.fieldPath) && (e.kind === 0 && t2.dir === "asc" || e.kind === 1 && t2.dir === "desc");
  }
};
var cr = class {
  constructor() {
    this.qe = new hr();
  }
  addToCollectionParentIndex(t2, e) {
    return this.qe.add(e), pi.resolve();
  }
  getCollectionParents(t2, e) {
    return pi.resolve(this.qe.getEntries(e));
  }
  addFieldIndex(t2, e) {
    return pi.resolve();
  }
  deleteFieldIndex(t2, e) {
    return pi.resolve();
  }
  getDocumentsMatchingTarget(t2, e) {
    return pi.resolve(null);
  }
  getFieldIndex(t2, e) {
    return pi.resolve(null);
  }
  getFieldIndexes(t2, e) {
    return pi.resolve([]);
  }
  getNextCollectionGroupToUpdate(t2) {
    return pi.resolve(null);
  }
  updateCollectionGroup(t2, e, n) {
    return pi.resolve();
  }
  updateIndexEntries(t2, e) {
    return pi.resolve();
  }
};
var hr = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new qn(_t.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new qn(_t.comparator)).toArray();
  }
};
var lr = new Uint8Array(0);
var fr = class {
  constructor(t2, e) {
    this.user = t2, this.databaseId = e, this.Ke = new hr(), this.Ge = new $n((t3) => _e(t3), (t3, e2) => me(t3, e2)), this.uid = t2.uid || "";
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.Ke.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.Ke.add(e);
      });
      const i = {
        collectionId: n,
        parent: Qs(s)
      };
      return dr(t2).put(i);
    }
    return pi.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [ut(e), ""], false, true);
    return dr(t2).qt(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(zs(s2.parent));
      }
      return n;
    });
  }
  addFieldIndex(t2, e) {
    const n = wr(t2), s = function(t3) {
      return {
        indexId: t3.indexId,
        collectionGroup: t3.collectionGroup,
        fields: t3.fields.map((t4) => [t4.fieldPath.canonicalString(), t4.kind])
      };
    }(e);
    return delete s.indexId, n.add(s).next();
  }
  deleteFieldIndex(t2, e) {
    const n = wr(t2), s = mr(t2), i = _r(t2);
    return n.delete(e.indexId).next(() => s.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true))).next(() => i.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true)));
  }
  getDocumentsMatchingTarget(t2, e) {
    const n = _r(t2);
    let s = true;
    const i = /* @__PURE__ */ new Map();
    return pi.forEach(this.Qe(e), (e2) => this.getFieldIndex(t2, e2).next((t3) => {
      s && (s = !!t3), i.set(e2, t3);
    })).next(() => {
      if (s) {
        let t3 = Xn();
        const s2 = [];
        return pi.forEach(i, (i2, r) => {
          var o;
          O2("IndexedDbIndexManager", `Using index ${o = i2, `id=${o.indexId}|cg=${o.collectionGroup}|f=${o.fields.map((t4) => `${t4.fieldPath}:${t4.kind}`).join(",")}`} to execute ${_e(e)}`);
          const u = function(t4, e2) {
            const n2 = ie(e2);
            if (n2 === void 0)
              return null;
            for (const e3 of ye(t4, n2.fieldPath))
              switch (e3.op) {
                case "array-contains-any":
                  return e3.value.arrayValue.values || [];
                case "array-contains":
                  return [e3.value];
              }
            return null;
          }(r, i2), a = function(t4, e2) {
            const n2 = /* @__PURE__ */ new Map();
            for (const s3 of re(e2))
              for (const e3 of ye(t4, s3.fieldPath))
                switch (e3.op) {
                  case "==":
                  case "in":
                    n2.set(s3.fieldPath.canonicalString(), e3.value);
                    break;
                  case "not-in":
                  case "!=":
                    return n2.set(s3.fieldPath.canonicalString(), e3.value), Array.from(n2.values());
                }
            return null;
          }(r, i2), c = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const i3 of re(e2)) {
              const e3 = i3.kind === 0 ? pe(t4, i3.fieldPath, t4.startAt) : Ie(t4, i3.fieldPath, t4.startAt);
              if (!e3.value)
                return null;
              n2.push(e3.value), s3 && (s3 = e3.inclusive);
            }
            return new De(n2, s3);
          }(r, i2), h = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const i3 of re(e2)) {
              const e3 = i3.kind === 0 ? Ie(t4, i3.fieldPath, t4.endAt) : pe(t4, i3.fieldPath, t4.endAt);
              if (!e3.value)
                return null;
              n2.push(e3.value), s3 && (s3 = e3.inclusive);
            }
            return new De(n2, s3);
          }(r, i2), l2 = this.je(i2, r, c), f = this.je(i2, r, h), d = this.We(i2, r, a), _ = this.ze(i2.indexId, u, l2, !!c && c.inclusive, f, !!h && h.inclusive, d);
          return pi.forEach(_, (i3) => n.Gt(i3, e.limit).next((e2) => {
            e2.forEach((e3) => {
              const n2 = xt.fromSegments(e3.documentKey);
              t3.has(n2) || (t3 = t3.add(n2), s2.push(n2));
            });
          }));
        }).next(() => s2);
      }
      return pi.resolve(null);
    });
  }
  Qe(t2) {
    let e = this.Ge.get(t2);
    return e || (e = [t2], this.Ge.set(t2, e), e);
  }
  ze(t2, e, n, s, i, r, o) {
    const u = (e != null ? e.length : 1) * Math.max(n != null ? n.length : 1, i != null ? i.length : 1), a = u / (e != null ? e.length : 1), c = [];
    for (let h = 0; h < u; ++h) {
      const u2 = e ? this.He(e[h / a]) : lr, l2 = n ? this.Je(t2, u2, n[h % a], s) : this.Ye(t2), f = i ? this.Xe(t2, u2, i[h % a], r) : this.Ye(t2 + 1);
      c.push(...this.createRange(l2, f, o.map((e2) => this.Je(t2, u2, e2, true))));
    }
    return c;
  }
  Je(t2, e, n, s) {
    const i = new rr(t2, xt.empty(), e, n);
    return s ? i : i.ke();
  }
  Xe(t2, e, n, s) {
    const i = new rr(t2, xt.empty(), e, n);
    return s ? i.ke() : i;
  }
  Ye(t2) {
    return new rr(t2, xt.empty(), lr, lr);
  }
  getFieldIndex(t2, e) {
    const n = new ar(e), s = e.collectionGroup != null ? e.collectionGroup : e.path.lastSegment();
    return this.getFieldIndexes(t2, s).next((t3) => {
      const e2 = t3.filter((t4) => n.$e(t4));
      return e2.sort((t4, e3) => e3.fields.length - t4.fields.length), e2.length > 0 ? e2[0] : null;
    });
  }
  Ze(t2, e) {
    const n = new ir();
    for (const s of re(t2)) {
      const t3 = e.data.field(s.fieldPath);
      if (t3 == null)
        return null;
      const i = n.Ne(s.kind);
      Xi.fe.Zt(t3, i);
    }
    return n.Se();
  }
  He(t2) {
    const e = new ir();
    return Xi.fe.Zt(t2, e.Ne(0)), e.Se();
  }
  tn(t2, e) {
    const n = new ir();
    return Xi.fe.Zt(qt(this.databaseId, e), n.Ne(function(t3) {
      const e2 = re(t3);
      return e2.length === 0 ? 0 : e2[e2.length - 1].kind;
    }(t2))), n.Se();
  }
  We(t2, e, n) {
    if (n === null)
      return [];
    let s = [];
    s.push(new ir());
    let i = 0;
    for (const r of re(t2)) {
      const t3 = n[i++];
      for (const n2 of s)
        if (this.en(e, r.fieldPath) && Gt(t3))
          s = this.nn(s, r, t3);
        else {
          const e2 = n2.Ne(r.kind);
          Xi.fe.Zt(t3, e2);
        }
    }
    return this.sn(s);
  }
  je(t2, e, n) {
    return n == null ? null : this.We(t2, e, n.position);
  }
  sn(t2) {
    const e = [];
    for (let n = 0; n < t2.length; ++n)
      e[n] = t2[n].Se();
    return e;
  }
  nn(t2, e, n) {
    const s = [...t2], i = [];
    for (const t3 of n.arrayValue.values || [])
      for (const n2 of s) {
        const s2 = new ir();
        s2.seed(n2.Se()), Xi.fe.Zt(t3, s2.Ne(e.kind)), i.push(s2);
      }
    return i;
  }
  en(t2, e) {
    return !!t2.filters.find((t3) => t3 instanceof Te && t3.field.isEqual(e) && (t3.op === "in" || t3.op === "not-in"));
  }
  getFieldIndexes(t2, e) {
    const n = wr(t2), s = mr(t2);
    return (e ? n.qt("collectionGroupIndex", IDBKeyRange.bound(e, e)) : n.qt()).next((t3) => {
      const e2 = [];
      return pi.forEach(t3, (t4) => s.get([t4.indexId, this.uid]).next((n2) => {
        e2.push(function(t5, e3) {
          const n3 = e3 ? new ue(e3.sequenceNumber, new he(Li(e3.readTime), new xt(zs(e3.documentKey)), e3.largestBatchId)) : ue.empty(), s2 = t5.fields.map(([t6, e4]) => new oe(mt.fromServerFormat(t6), e4));
          return new se(t5.indexId, t5.collectionGroup, s2, n3);
        }(t4, n2));
      })).next(() => e2);
    });
  }
  getNextCollectionGroupToUpdate(t2) {
    return this.getFieldIndexes(t2).next((t3) => t3.length === 0 ? null : (t3.sort((t4, e) => {
      const n = t4.indexState.sequenceNumber - e.indexState.sequenceNumber;
      return n !== 0 ? n : rt(t4.collectionGroup, e.collectionGroup);
    }), t3[0].collectionGroup));
  }
  updateCollectionGroup(t2, e, n) {
    const s = wr(t2), i = mr(t2);
    return this.rn(t2).next((t3) => s.qt("collectionGroupIndex", IDBKeyRange.bound(e, e)).next((e2) => pi.forEach(e2, (e3) => i.put(function(t4, e4, n2, s2) {
      return {
        indexId: t4,
        uid: e4.uid || "",
        sequenceNumber: n2,
        readTime: Bi(s2.readTime),
        documentKey: Qs(s2.documentKey.path),
        largestBatchId: s2.largestBatchId
      };
    }(e3.indexId, this.user, t3, n)))));
  }
  updateIndexEntries(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return pi.forEach(e, (e2, s) => {
      const i = n.get(e2.collectionGroup);
      return (i ? pi.resolve(i) : this.getFieldIndexes(t2, e2.collectionGroup)).next((i2) => (n.set(e2.collectionGroup, i2), pi.forEach(i2, (n2) => this.on(t2, e2, n2).next((e3) => {
        const i3 = this.un(s, n2);
        return e3.isEqual(i3) ? pi.resolve() : this.an(t2, s, n2, e3, i3);
      }))));
    });
  }
  cn(t2, e, n, s) {
    return _r(t2).put({
      indexId: s.indexId,
      uid: this.uid,
      arrayValue: s.arrayValue,
      directionalValue: s.directionalValue,
      orderedDocumentKey: this.tn(n, e.key),
      documentKey: e.key.path.toArray()
    });
  }
  hn(t2, e, n, s) {
    return _r(t2).delete([s.indexId, this.uid, s.arrayValue, s.directionalValue, this.tn(n, e.key), e.key.path.toArray()]);
  }
  on(t2, e, n) {
    const s = _r(t2);
    let i = new qn(or);
    return s.Wt({
      index: "documentKeyIndex",
      range: IDBKeyRange.only([n.indexId, this.uid, this.tn(n, e)])
    }, (t3, s2) => {
      i = i.add(new rr(n.indexId, e, s2.arrayValue, s2.directionalValue));
    }).next(() => i);
  }
  un(t2, e) {
    let n = new qn(or);
    const s = this.Ze(e, t2);
    if (s == null)
      return n;
    const i = ie(e);
    if (i != null) {
      const r = t2.data.field(i.fieldPath);
      if (Gt(r))
        for (const i2 of r.arrayValue.values || [])
          n = n.add(new rr(e.indexId, t2.key, this.He(i2), s));
    } else
      n = n.add(new rr(e.indexId, t2.key, lr, s));
    return n;
  }
  an(t2, e, n, s, i) {
    O2("IndexedDbIndexManager", "Updating index entries for document '%s'", e.key);
    const r = [];
    return function(t3, e2, n2, s2, i2) {
      const r2 = t3.getIterator(), o = e2.getIterator();
      let u = Gn(r2), a = Gn(o);
      for (; u || a; ) {
        let t4 = false, e3 = false;
        if (u && a) {
          const s3 = n2(u, a);
          s3 < 0 ? e3 = true : s3 > 0 && (t4 = true);
        } else
          u != null ? e3 = true : t4 = true;
        t4 ? (s2(a), a = Gn(o)) : e3 ? (i2(u), u = Gn(r2)) : (u = Gn(r2), a = Gn(o));
      }
    }(s, i, or, (s2) => {
      r.push(this.cn(t2, e, n, s2));
    }, (s2) => {
      r.push(this.hn(t2, e, n, s2));
    }), pi.waitFor(r);
  }
  rn(t2) {
    let e = 1;
    return mr(t2).Wt({
      index: "sequenceNumberIndex",
      reverse: true,
      range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])
    }, (t3, n, s) => {
      s.done(), e = n.sequenceNumber + 1;
    }).next(() => e);
  }
  createRange(t2, e, n) {
    n = n.sort((t3, e2) => or(t3, e2)).filter((t3, e2, n2) => !e2 || or(t3, n2[e2 - 1]) !== 0);
    const s = [];
    s.push(t2);
    for (const i2 of n) {
      const n2 = or(i2, t2), r = or(i2, e);
      if (n2 === 0)
        s[0] = t2.ke();
      else if (n2 > 0 && r < 0)
        s.push(i2), s.push(i2.ke());
      else if (r > 0)
        break;
    }
    s.push(e);
    const i = [];
    for (let t3 = 0; t3 < s.length; t3 += 2)
      i.push(IDBKeyRange.bound([s[t3].indexId, this.uid, s[t3].arrayValue, s[t3].directionalValue, lr, []], [s[t3 + 1].indexId, this.uid, s[t3 + 1].arrayValue, s[t3 + 1].directionalValue, lr, []]));
    return i;
  }
};
function dr(t2) {
  return Di(t2, "collectionParents");
}
function _r(t2) {
  return Di(t2, "indexEntries");
}
function wr(t2) {
  return Di(t2, "indexConfiguration");
}
function mr(t2) {
  return Di(t2, "indexState");
}
var gr = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var yr = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new yr(t2, yr.DEFAULT_COLLECTION_PERCENTILE, yr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function pr(t2, e, n) {
  const s = t2.store("mutations"), i = t2.store("documentMutations"), r = [], o = IDBKeyRange.only(n.batchId);
  let u = 0;
  const a = s.Wt({
    range: o
  }, (t3, e2, n2) => (u++, n2.delete()));
  r.push(a.next(() => {
    U2(u === 1);
  }));
  const c = [];
  for (const t3 of n.mutations) {
    const s2 = Ys(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), c.push(t3.key);
  }
  return pi.waitFor(r).next(() => c);
}
function Ir(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw L2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
yr.DEFAULT_COLLECTION_PERCENTILE = 10, yr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, yr.DEFAULT = new yr(41943040, yr.DEFAULT_COLLECTION_PERCENTILE, yr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), yr.DISABLED = new yr(-1, 0, 0);
var Tr = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.M = e, this.indexManager = n, this.referenceDelegate = s, this.ln = {};
  }
  static Yt(t2, e, n, s) {
    U2(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new Tr(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return Ar(t2).Wt({
      index: "userMutationsIndex",
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = Rr(t2), r = Ar(t2);
    return r.add({}).next((o) => {
      U2(typeof o == "number");
      const u = new Ci(o, e, n, s), a = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => Ss(t3.Jt, e3)), i2 = n2.mutations.map((e3) => Ss(t3.Jt, e3));
        return {
          userId: e2,
          batchId: n2.batchId,
          localWriteTimeMs: n2.localWriteTime.toMillis(),
          baseMutations: s2,
          mutations: i2
        };
      }(this.M, this.userId, u), c = [];
      let h = new qn((t3, e2) => rt(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = Ys(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), c.push(r.put(a)), c.push(i.put(e2, Xs));
      }
      return h.forEach((e2) => {
        c.push(this.indexManager.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.ln[o] = u.keys();
      }), pi.waitFor(c).next(() => u);
    });
  }
  lookupMutationBatch(t2, e) {
    return Ar(t2).get(e).next((t3) => t3 ? (U2(t3.userId === this.userId), Ui(this.M, t3)) : null);
  }
  fn(t2, e) {
    return this.ln[e] ? pi.resolve(this.ln[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.ln[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return Ar(t2).Wt({
      index: "userMutationsIndex",
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (U2(e2.batchId >= n), i = Ui(this.M, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return Ar(t2).Wt({
      index: "userMutationsIndex",
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return Ar(t2).qt("userMutationsIndex", e).next((t3) => t3.map((t4) => Ui(this.M, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = Js(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return Rr(t2).Wt({
      range: s
    }, (n2, s2, r) => {
      const [o, u, a] = n2, c = zs(u);
      if (o === this.userId && e.path.isEqual(c))
        return Ar(t2).get(a).next((t3) => {
          if (!t3)
            throw L2();
          U2(t3.userId === this.userId), i.push(Ui(this.M, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new qn(rt);
    const s = [];
    return e.forEach((e2) => {
      const i = Js(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = Rr(t2).Wt({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, u] = t3, a = zs(o2);
        r2 === this.userId && e2.path.isEqual(a) ? n = n.add(u) : i2.done();
      });
      s.push(o);
    }), pi.waitFor(s).next(() => this.dn(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = Js(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new qn(rt);
    return Rr(t2).Wt({
      range: r
    }, (t3, e2, i2) => {
      const [r2, u, a] = t3, c = zs(u);
      r2 === this.userId && n.isPrefixOf(c) ? c.length === s && (o = o.add(a)) : i2.done();
    }).next(() => this.dn(t2, o));
  }
  dn(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(Ar(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw L2();
        U2(t3.userId === this.userId), n.push(Ui(this.M, t3));
      }));
    }), pi.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return pr(t2.Ht, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this._n(e.batchId);
    }), pi.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  _n(t2) {
    delete this.ln[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return pi.resolve();
      const n = IDBKeyRange.lowerBound([this.userId]);
      const s = [];
      return Rr(t2).Wt({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = zs(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        U2(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return Er(t2, this.userId, e);
  }
  wn(t2) {
    return Pr(t2).get(this.userId).next((t3) => t3 || {
      userId: this.userId,
      lastAcknowledgedBatchId: -1,
      lastStreamToken: ""
    });
  }
};
function Er(t2, e, n) {
  const s = Js(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return Rr(t2).Wt({
    range: r,
    jt: true
  }, (t3, n2, s2) => {
    const [r2, u, a] = t3;
    r2 === e && u === i && (o = true), s2.done();
  }).next(() => o);
}
function Ar(t2) {
  return Di(t2, "mutations");
}
function Rr(t2) {
  return Di(t2, "documentMutations");
}
function Pr(t2) {
  return Di(t2, "mutationQueues");
}
var br = class {
  constructor(t2) {
    this.mn = t2;
  }
  next() {
    return this.mn += 2, this.mn;
  }
  static gn() {
    return new br(0);
  }
  static yn() {
    return new br(-1);
  }
};
var Vr = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.M = e;
  }
  allocateTargetId(t2) {
    return this.pn(t2).next((e) => {
      const n = new br(e.highestTargetId);
      return e.highestTargetId = n.next(), this.In(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.pn(t2).next((t3) => ct.fromTimestamp(new at(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.pn(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.pn(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.In(t2, s)));
  }
  addTargetData(t2, e) {
    return this.Tn(t2, e).next(() => this.pn(t2).next((n) => (n.targetCount += 1, this.En(e, n), this.In(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.Tn(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => vr(t2).delete(e.targetId)).next(() => this.pn(t2)).next((e2) => (U2(e2.targetCount > 0), e2.targetCount -= 1, this.In(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return vr(t2).Wt((r, o) => {
      const u = qi(o);
      u.sequenceNumber <= e && n.get(u.targetId) === null && (s++, i.push(this.removeTargetData(t2, u)));
    }).next(() => pi.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return vr(t2).Wt((t3, n) => {
      const s = qi(n);
      e(s);
    });
  }
  pn(t2) {
    return Sr(t2).get("targetGlobalKey").next((t3) => (U2(t3 !== null), t3));
  }
  In(t2, e) {
    return Sr(t2).put("targetGlobalKey", e);
  }
  Tn(t2, e) {
    return vr(t2).put(Ki(this.M, e));
  }
  En(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.pn(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = _e(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return vr(t2).Wt({
      range: s,
      index: "queryTargetsIndex"
    }, (t3, n2, s2) => {
      const r = qi(n2);
      me(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = Dr(t2);
    return e.forEach((e2) => {
      const r = Qs(e2.path);
      s.push(i.put({
        targetId: n,
        path: r
      })), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), pi.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = Dr(t2);
    return pi.forEach(e, (e2) => {
      const i = Qs(e2.path);
      return pi.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = Dr(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = Dr(t2);
    let i = Xn();
    return s.Wt({
      range: n,
      jt: true
    }, (t3, e2, n2) => {
      const s2 = zs(t3[1]), r = new xt(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = Qs(e.path), s = IDBKeyRange.bound([n], [ut(n)], false, true);
    let i = 0;
    return Dr(t2).Wt({
      index: "documentTargetsIndex",
      jt: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  Et(t2, e) {
    return vr(t2).get(e).next((t3) => t3 ? qi(t3) : null);
  }
};
function vr(t2) {
  return Di(t2, "targets");
}
function Sr(t2) {
  return Di(t2, "targetGlobal");
}
function Dr(t2) {
  return Di(t2, "targetDocuments");
}
async function Cr(t2) {
  if (t2.code !== G.FAILED_PRECONDITION || t2.message !== gi)
    throw t2;
  O2("LocalStore", "Unexpectedly lost primary lease");
}
function xr([t2, e], [n, s]) {
  const i = rt(t2, n);
  return i === 0 ? rt(e, s) : i;
}
var Nr = class {
  constructor(t2) {
    this.An = t2, this.buffer = new qn(xr), this.Rn = 0;
  }
  Pn() {
    return ++this.Rn;
  }
  bn(t2) {
    const e = [t2, this.Pn()];
    if (this.buffer.size < this.An)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      xr(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var kr = class {
  constructor(t2, e) {
    this.garbageCollector = t2, this.asyncQueue = e, this.Vn = false, this.vn = null;
  }
  start(t2) {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.Sn(t2);
  }
  stop() {
    this.vn && (this.vn.cancel(), this.vn = null);
  }
  get started() {
    return this.vn !== null;
  }
  Sn(t2) {
    const e = this.Vn ? 3e5 : 6e4;
    O2("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.vn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this.vn = null, this.Vn = true;
      try {
        await t2.collectGarbage(this.garbageCollector);
      } catch (t3) {
        Ri(t3) ? O2("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await Cr(t3);
      }
      await this.Sn(t2);
    });
  }
};
var Mr = class {
  constructor(t2, e) {
    this.Dn = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.Dn.Cn(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return pi.resolve(nt.A);
    const n = new Nr(e);
    return this.Dn.forEachTarget(t2, (t3) => n.bn(t3.sequenceNumber)).next(() => this.Dn.xn(t2, (t3) => n.bn(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.Dn.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.Dn.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? (O2("LruGarbageCollector", "Garbage collection skipped; disabled"), pi.resolve(gr)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? (O2("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), gr) : this.Nn(t2, e));
  }
  getCacheSize(t2) {
    return this.Dn.getCacheSize(t2);
  }
  Nn(t2, e) {
    let n, s, i, r, o, a, c;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (O2("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, a = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (c = Date.now(), k2() <= LogLevel.DEBUG) {
        O2("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (a - o) + `ms
	Removed ${t3} documents in ` + (c - a) + `ms
Total Duration: ${c - h}ms`);
      }
      return pi.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var Or = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new Mr(t3, e2);
    }(this, e);
  }
  Cn(t2) {
    const e = this.kn(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  kn(t2) {
    let e = 0;
    return this.xn(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  xn(t2, e) {
    return this.Mn(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return Fr(t2, n);
  }
  removeReference(t2, e, n) {
    return Fr(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return Fr(t2, e);
  }
  On(t2, e) {
    return function(t3, e2) {
      let n = false;
      return Pr(t3).zt((s) => Er(t3, s, e2).next((t4) => (t4 && (n = true), pi.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.Mn(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.On(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r, ct.min()), Dr(t2).delete([0, Qs(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => pi.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return Fr(t2, e);
  }
  Mn(t2, e) {
    const n = Dr(t2);
    let s, i = nt.A;
    return n.Wt({
      index: "documentTargetsIndex"
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      t3 === 0 ? (i !== nt.A && e(new xt(zs(s)), i), i = o, s = r) : i = nt.A;
    }).next(() => {
      i !== nt.A && e(new xt(zs(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function Fr(t2, e) {
  return Dr(t2).put(function(t3, e2) {
    return {
      targetId: 0,
      path: Qs(t3.path),
      sequenceNumber: e2
    };
  }(e, t2.currentSequenceNumber));
}
var $r = class {
  constructor() {
    this.changes = new $n((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  addEntry(t2) {
    this.assertNotApplied(), this.changes.set(t2.key, t2);
  }
  removeEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2, ne.newInvalidDocument(t2).setReadTime(e));
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? pi.resolve(n) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var Br = class {
  constructor(t2) {
    this.M = t2;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e, n) {
    return qr(t2).put(n);
  }
  removeEntry(t2, e, n) {
    return qr(t2).delete(function(t3, e2) {
      const n2 = t3.path.toArray();
      return [
        n2.slice(0, n2.length - 2),
        n2[n2.length - 2],
        $i(e2),
        n2[n2.length - 1]
      ];
    }(e, n));
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.Fn(t2, n)));
  }
  getEntry(t2, e) {
    let n = ne.newInvalidDocument(e);
    return qr(t2).Wt({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(Kr(e))
    }, (t3, s) => {
      n = this.$n(e, s);
    }).next(() => n);
  }
  Bn(t2, e) {
    let n = {
      size: 0,
      document: ne.newInvalidDocument(e)
    };
    return qr(t2).Wt({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(Kr(e))
    }, (t3, s) => {
      n = {
        document: this.$n(e, s),
        size: Ir(s)
      };
    }).next(() => n);
  }
  getEntries(t2, e) {
    let n = jn();
    return this.Ln(t2, e, (t3, e2) => {
      const s = this.$n(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  Un(t2, e) {
    let n = jn(), s = new Bn(xt.comparator);
    return this.Ln(t2, e, (t3, e2) => {
      const i = this.$n(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, Ir(e2));
    }).next(() => ({
      documents: n,
      qn: s
    }));
  }
  Ln(t2, e, n) {
    if (e.isEmpty())
      return pi.resolve();
    let s = new qn(Qr);
    e.forEach((t3) => s = s.add(t3));
    const i = IDBKeyRange.bound(Kr(s.first()), Kr(s.last())), r = s.getIterator();
    let o = r.getNext();
    return qr(t2).Wt({
      index: "documentKeyIndex",
      range: i
    }, (t3, e2, s2) => {
      const i2 = xt.fromSegments([...e2.prefixPath, e2.collectionGroup, e2.documentId]);
      for (; o && Qr(o, i2) < 0; )
        n(o, null), o = r.getNext();
      o && o.isEqual(i2) && (n(o, e2), o = r.hasNext() ? r.getNext() : null), o ? s2.Ut(Kr(o)) : s2.done();
    }).next(() => {
      for (; o; )
        n(o, null), o = r.hasNext() ? r.getNext() : null;
    });
  }
  getAllFromCollection(t2, e, n) {
    const s = [e.popLast().toArray(), e.lastSegment(), $i(n.readTime), n.documentKey.path.isEmpty() ? "" : n.documentKey.path.lastSegment()], i = [e.popLast().toArray(), e.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""];
    return qr(t2).qt(IDBKeyRange.bound(s, i, true)).next((t3) => {
      let e2 = jn();
      for (const n2 of t3) {
        const t4 = this.$n(xt.fromSegments(n2.prefixPath.concat(n2.collectionGroup, n2.documentId)), n2);
        e2 = e2.insert(t4.key, t4);
      }
      return e2;
    });
  }
  getAllFromCollectionGroup(t2, e, n, s) {
    let i = jn();
    const r = Gr(e, n), o = Gr(e, he.max());
    return qr(t2).Wt({
      index: "collectionGroupIndex",
      range: IDBKeyRange.bound(r, o, true)
    }, (t3, e2, n2) => {
      const r2 = this.$n(xt.fromSegments(e2.prefixPath.concat(e2.collectionGroup, e2.documentId)), e2);
      i = i.insert(r2.key, r2), i.size === s && n2.done();
    }).next(() => i);
  }
  newChangeBuffer(t2) {
    return new Lr(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Ur(t2).get("remoteDocumentGlobalKey").next((t3) => (U2(!!t3), t3));
  }
  Fn(t2, e) {
    return Ur(t2).put("remoteDocumentGlobalKey", e);
  }
  $n(t2, e) {
    if (e) {
      const t3 = Oi(this.M, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(ct.min())))
        return t3;
    }
    return ne.newInvalidDocument(t2);
  }
};
var Lr = class extends $r {
  constructor(t2, e) {
    super(), this.Kn = t2, this.trackRemovals = e, this.Gn = new $n((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new qn((t3, e2) => rt(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.Gn.get(i);
      if (e.push(this.Kn.removeEntry(t2, i, o.readTime)), r.isValidDocument()) {
        const u = Fi(this.Kn.M, r);
        s = s.add(i.path.popLast());
        const a = Ir(u);
        n += a - o.size, e.push(this.Kn.addEntry(t2, i, u));
      } else if (n -= o.size, this.trackRemovals) {
        const n2 = Fi(this.Kn.M, r.convertToNoDocument(ct.min()));
        e.push(this.Kn.addEntry(t2, i, n2));
      }
    }), s.forEach((n2) => {
      e.push(this.Kn.indexManager.addToCollectionParentIndex(t2, n2));
    }), e.push(this.Kn.updateMetadata(t2, n)), pi.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Kn.Bn(t2, e).next((t3) => (this.Gn.set(e, {
      size: t3.size,
      readTime: t3.document.readTime
    }), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.Kn.Un(t2, e).next(({ documents: t3, qn: e2 }) => (e2.forEach((e3, n) => {
      this.Gn.set(e3, {
        size: n,
        readTime: t3.get(e3).readTime
      });
    }), t3));
  }
};
function Ur(t2) {
  return Di(t2, "remoteDocumentGlobal");
}
function qr(t2) {
  return Di(t2, "remoteDocumentsV14");
}
function Kr(t2) {
  const e = t2.path.toArray();
  return [
    e.slice(0, e.length - 2),
    e[e.length - 2],
    e[e.length - 1]
  ];
}
function Gr(t2, e) {
  const n = e.documentKey.path.toArray();
  return [
    t2,
    $i(e.readTime),
    n.slice(0, n.length - 2),
    n.length > 0 ? n[n.length - 1] : ""
  ];
}
function Qr(t2, e) {
  const n = t2.path.toArray(), s = e.path.toArray();
  let i = 0;
  for (let t3 = 0; t3 < n.length - 2 && t3 < s.length - 2; ++t3)
    if (i = rt(n[t3], s[t3]), i)
      return i;
  return i = rt(n.length, s.length), i || (i = rt(n[n.length - 2], s[s.length - 2]), i || rt(n[n.length - 1], s[s.length - 1]));
}
var jr = class {
  constructor(t2) {
    this.M = t2;
  }
  kt(t2, e, n, s) {
    const i = new Ii("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore("owner");
    }(t2), function(t3) {
      t3.createObjectStore("mutationQueues", {
        keyPath: "userId"
      });
      t3.createObjectStore("mutations", {
        keyPath: "batchId",
        autoIncrement: true
      }).createIndex("userMutationsIndex", Hs, {
        unique: true
      }), t3.createObjectStore("documentMutations");
    }(t2), Wr(t2), function(t3) {
      t3.createObjectStore("remoteDocuments");
    }(t2));
    let r = pi.resolve();
    return n < 3 && s >= 3 && (n !== 0 && (!function(t3) {
      t3.deleteObjectStore("targetDocuments"), t3.deleteObjectStore("targets"), t3.deleteObjectStore("targetGlobal");
    }(t2), Wr(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store("targetGlobal"), n2 = {
        highestTargetId: 0,
        highestListenSequenceNumber: 0,
        lastRemoteSnapshotVersion: ct.min().toTimestamp(),
        targetCount: 0
      };
      return e2.put("targetGlobalKey", n2);
    }(i))), n < 4 && s >= 4 && (n !== 0 && (r = r.next(() => function(t3, e2) {
      return e2.store("mutations").qt().next((n2) => {
        t3.deleteObjectStore("mutations");
        t3.createObjectStore("mutations", {
          keyPath: "batchId",
          autoIncrement: true
        }).createIndex("userMutationsIndex", Hs, {
          unique: true
        });
        const s2 = e2.store("mutations"), i2 = n2.map((t4) => s2.put(t4));
        return pi.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("clientMetadata", {
          keyPath: "clientId"
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Qn(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore("remoteDocumentGlobal");
    }(t2), this.jn(i)))), n < 7 && s >= 7 && (r = r.next(() => this.Wn(i))), n < 8 && s >= 8 && (r = r.next(() => this.zn(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2);
    })), n < 10 && s >= 10 && (r = r.next(() => this.Hn(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("bundles", {
          keyPath: "bundleId"
        });
      }(t2), function(t3) {
        t3.createObjectStore("namedQueries", {
          keyPath: "name"
        });
      }(t2);
    })), n < 12 && s >= 12 && (r = r.next(() => {
      !function(t3) {
        const e2 = t3.createObjectStore("documentOverlays", {
          keyPath: hi
        });
        e2.createIndex("collectionPathOverlayIndex", li, {
          unique: false
        }), e2.createIndex("collectionGroupOverlayIndex", fi, {
          unique: false
        });
      }(t2);
    })), n < 13 && s >= 13 && (r = r.next(() => function(t3) {
      const e2 = t3.createObjectStore("remoteDocumentsV14", {
        keyPath: Zs
      });
      e2.createIndex("documentKeyIndex", ti), e2.createIndex("collectionGroupIndex", ei);
    }(t2)).next(() => this.Jn(t2, i)).next(() => t2.deleteObjectStore("remoteDocuments"))), n < 14 && s >= 14 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("indexConfiguration", {
          keyPath: "indexId",
          autoIncrement: true
        }).createIndex("collectionGroupIndex", "collectionGroup", {
          unique: false
        });
        t3.createObjectStore("indexState", {
          keyPath: oi
        }).createIndex("sequenceNumberIndex", ui, {
          unique: false
        });
        t3.createObjectStore("indexEntries", {
          keyPath: ai
        }).createIndex("documentKeyIndex", ci, {
          unique: false
        });
      }(t2);
    })), r;
  }
  jn(t2) {
    let e = 0;
    return t2.store("remoteDocuments").Wt((t3, n) => {
      e += Ir(n);
    }).next(() => {
      const n = {
        byteSize: e
      };
      return t2.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", n);
    });
  }
  Qn(t2) {
    const e = t2.store("mutationQueues"), n = t2.store("mutations");
    return e.qt().next((e2) => pi.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.qt("userMutationsIndex", s).next((n2) => pi.forEach(n2, (n3) => {
        U2(n3.userId === e3.userId);
        const s2 = Ui(this.M, n3);
        return pr(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  Wn(t2) {
    const e = t2.store("targetDocuments"), n = t2.store("remoteDocuments");
    return t2.store("targetGlobal").get("targetGlobalKey").next((t3) => {
      const s = [];
      return n.Wt((n2, i) => {
        const r = new _t(n2), o = function(t4) {
          return [0, Qs(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? pi.resolve() : ((n4) => e.put({
          targetId: 0,
          path: Qs(n4),
          sequenceNumber: t3.highestListenSequenceNumber
        }))(r)));
      }).next(() => pi.waitFor(s));
    });
  }
  zn(t2, e) {
    t2.createObjectStore("collectionParents", {
      keyPath: ri
    });
    const n = e.store("collectionParents"), s = new hr(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: Qs(s2)
        });
      }
    };
    return e.store("remoteDocuments").Wt({
      jt: true
    }, (t3, e2) => {
      const n2 = new _t(t3);
      return i(n2.popLast());
    }).next(() => e.store("documentMutations").Wt({
      jt: true
    }, ([t3, e2, n2], s2) => {
      const r = zs(e2);
      return i(r.popLast());
    }));
  }
  Hn(t2) {
    const e = t2.store("targets");
    return e.Wt((t3, n) => {
      const s = qi(n), i = Ki(this.M, s);
      return e.put(i);
    });
  }
  Jn(t2, e) {
    const n = e.store("remoteDocuments"), s = [];
    return n.Wt((t3, n2) => {
      const i = e.store("remoteDocumentsV14"), r = (o = n2, o.document ? new xt(_t.fromString(o.document.name).popFirst(5)) : o.noDocument ? xt.fromSegments(o.noDocument.path) : o.unknownDocument ? xt.fromSegments(o.unknownDocument.path) : L2()).path.toArray();
      var o;
      const u = {
        prefixPath: r.slice(0, r.length - 2),
        collectionGroup: r[r.length - 2],
        documentId: r[r.length - 1],
        readTime: n2.readTime || [0, 0],
        unknownDocument: n2.unknownDocument,
        noDocument: n2.noDocument,
        document: n2.document,
        hasCommittedMutations: !!n2.hasCommittedMutations
      };
      s.push(i.put(u));
    }).next(() => pi.waitFor(s));
  }
};
function Wr(t2) {
  t2.createObjectStore("targetDocuments", {
    keyPath: si
  }).createIndex("documentTargetsIndex", ii, {
    unique: true
  });
  t2.createObjectStore("targets", {
    keyPath: "targetId"
  }).createIndex("queryTargetsIndex", ni, {
    unique: true
  }), t2.createObjectStore("targetGlobal");
}
var zr = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var Hr = class {
  constructor(t2, e, n, s, i, r, o, u, a, c, h = 13) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Yn = i, this.window = r, this.document = o, this.Xn = a, this.Zn = c, this.ts = h, this.es = null, this.ns = false, this.isPrimary = false, this.networkEnabled = true, this.ss = null, this.inForeground = false, this.rs = null, this.os = null, this.us = Number.NEGATIVE_INFINITY, this.cs = (t3) => Promise.resolve(), !Hr.vt())
      throw new Q2(G.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new Or(this, s), this.hs = e + "main", this.M = new Mi(u), this.ls = new Ti(this.hs, this.ts, new jr(this.M)), this.fs = new Vr(this.referenceDelegate, this.M), this.ds = function(t3) {
      return new Br(t3);
    }(this.M), this._s = new Wi(), this.window && this.window.localStorage ? this.ws = this.window.localStorage : (this.ws = null, c === false && F2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.gs().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new Q2(G.FAILED_PRECONDITION, zr);
      return this.ys(), this.ps(), this.Is(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.fs.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.es = new nt(t2, this.Xn);
    }).then(() => {
      this.ns = true;
    }).catch((t2) => (this.ls && this.ls.close(), Promise.reject(t2)));
  }
  Ts(t2) {
    return this.cs = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.ls.Ot(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Yn.enqueueAndForget(async () => {
      this.started && await this.gs();
    }));
  }
  gs() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => Yr(t2).put({
      clientId: this.clientId,
      updateTimeMs: Date.now(),
      networkEnabled: this.networkEnabled,
      inForeground: this.inForeground
    }).next(() => {
      if (this.isPrimary)
        return this.Es(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Yn.enqueueRetryable(() => this.cs(false)));
        });
    }).next(() => this.As(t2)).next((e) => this.isPrimary && !e ? this.Rs(t2).next(() => false) : !!e && this.Ps(t2).next(() => true))).catch((t2) => {
      if (Ri(t2))
        return O2("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return O2("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Yn.enqueueRetryable(() => this.cs(t2)), this.isPrimary = t2;
    });
  }
  Es(t2) {
    return Jr(t2).get("owner").next((t3) => pi.resolve(this.bs(t3)));
  }
  Vs(t2) {
    return Yr(t2).delete(this.clientId);
  }
  async vs() {
    if (this.isPrimary && !this.Ss(this.us, 18e5)) {
      this.us = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = Di(t3, "clientMetadata");
        return e.qt().next((t4) => {
          const n = this.Ds(t4, 18e5), s = t4.filter((t5) => n.indexOf(t5) === -1);
          return pi.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.ws)
        for (const e of t2)
          this.ws.removeItem(this.Cs(e.clientId));
    }
  }
  Is() {
    this.os = this.Yn.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.gs().then(() => this.vs()).then(() => this.Is()));
  }
  bs(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  As(t2) {
    if (this.Zn)
      return pi.resolve(true);
    return Jr(t2).get("owner").next((e) => {
      if (e !== null && this.Ss(e.leaseTimestampMs, 5e3) && !this.xs(e.ownerId)) {
        if (this.bs(e) && this.networkEnabled)
          return true;
        if (!this.bs(e)) {
          if (!e.allowTabSynchronization)
            throw new Q2(G.FAILED_PRECONDITION, zr);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || Yr(t2).qt().next((t3) => this.Ds(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && O2("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.ns = false, this.Ns(), this.os && (this.os.cancel(), this.os = null), this.ks(), this.Ms(), await this.ls.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], (t2) => {
      const e = new Si(t2, nt.A);
      return this.Rs(e).next(() => this.Vs(e));
    }), this.ls.close(), this.Os();
  }
  Ds(t2, e) {
    return t2.filter((t3) => this.Ss(t3.updateTimeMs, e) && !this.xs(t3.clientId));
  }
  Fs() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => Yr(t2).qt().next((t3) => this.Ds(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.ns;
  }
  getMutationQueue(t2, e) {
    return Tr.Yt(t2, this.M, e, this.referenceDelegate);
  }
  getTargetCache() {
    return this.fs;
  }
  getRemoteDocumentCache() {
    return this.ds;
  }
  getIndexManager(t2) {
    return new fr(t2, this.M.Jt.databaseId);
  }
  getDocumentOverlayCache(t2) {
    return Ji.Yt(this.M, t2);
  }
  getBundleCache() {
    return this._s;
  }
  runTransaction(t2, e, n) {
    O2("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite", i = (r = this.ts) === 14 ? mi : r === 13 ? wi : r === 12 ? _i : r === 11 ? di : void L2();
    var r;
    let o;
    return this.ls.runTransaction(t2, s, i, (s2) => (o = new Si(s2, this.es ? this.es.next() : nt.A), e === "readwrite-primary" ? this.Es(o).next((t3) => !!t3 || this.As(o)).next((e2) => {
      if (!e2)
        throw F2(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Yn.enqueueRetryable(() => this.cs(false)), new Q2(G.FAILED_PRECONDITION, gi);
      return n(o);
    }).next((t3) => this.Ps(o).next(() => t3)) : this.$s(o).next(() => n(o)))).then((t3) => (o.raiseOnCommittedEvent(), t3));
  }
  $s(t2) {
    return Jr(t2).get("owner").next((t3) => {
      if (t3 !== null && this.Ss(t3.leaseTimestampMs, 5e3) && !this.xs(t3.ownerId) && !this.bs(t3) && !(this.Zn || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new Q2(G.FAILED_PRECONDITION, zr);
    });
  }
  Ps(t2) {
    const e = {
      ownerId: this.clientId,
      allowTabSynchronization: this.allowTabSynchronization,
      leaseTimestampMs: Date.now()
    };
    return Jr(t2).put("owner", e);
  }
  static vt() {
    return Ti.vt();
  }
  Rs(t2) {
    const e = Jr(t2);
    return e.get("owner").next((t3) => this.bs(t3) ? (O2("IndexedDbPersistence", "Releasing primary lease."), e.delete("owner")) : pi.resolve());
  }
  Ss(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || (F2(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  ys() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.rs = () => {
      this.Yn.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.gs()));
    }, this.document.addEventListener("visibilitychange", this.rs), this.inForeground = this.document.visibilityState === "visible");
  }
  ks() {
    this.rs && (this.document.removeEventListener("visibilitychange", this.rs), this.rs = null);
  }
  ps() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.ss = () => {
      this.Ns(), isSafari() && navigator.appVersion.match(/Version\/1[45]/) && this.Yn.enterRestrictedMode(true), this.Yn.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.ss));
  }
  Ms() {
    this.ss && (this.window.removeEventListener("pagehide", this.ss), this.ss = null);
  }
  xs(t2) {
    var e;
    try {
      const n = ((e = this.ws) === null || e === void 0 ? void 0 : e.getItem(this.Cs(t2))) !== null;
      return O2("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return F2("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  Ns() {
    if (this.ws)
      try {
        this.ws.setItem(this.Cs(this.clientId), String(Date.now()));
      } catch (t2) {
        F2("Failed to set zombie client id.", t2);
      }
  }
  Os() {
    if (this.ws)
      try {
        this.ws.removeItem(this.Cs(this.clientId));
      } catch (t2) {
      }
  }
  Cs(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function Jr(t2) {
  return Di(t2, "owner");
}
function Yr(t2) {
  return Di(t2, "clientMetadata");
}
function Xr(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var Zr = class {
  constructor(t2, e, n) {
    this.ds = t2, this.Bs = e, this.indexManager = n;
  }
  Ls(t2, e) {
    return this.Bs.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n) => this.Us(t2, e, n));
  }
  Us(t2, e, n) {
    return this.ds.getEntry(t2, e).next((t3) => {
      for (const e2 of n)
        e2.applyToLocalView(t3);
      return t3;
    });
  }
  qs(t2, e) {
    t2.forEach((t3, n) => {
      for (const t4 of e)
        t4.applyToLocalView(n);
    });
  }
  Ks(t2, e) {
    return this.ds.getEntries(t2, e).next((e2) => this.Gs(t2, e2).next(() => e2));
  }
  Gs(t2, e) {
    return this.Bs.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.qs(e, t3));
  }
  Qs(t2, e, n) {
    return function(t3) {
      return xt.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.js(t2, e.path) : qe(e) ? this.Ws(t2, e, n) : this.zs(t2, e, n);
  }
  js(t2, e) {
    return this.Ls(t2, new xt(e)).next((t3) => {
      let e2 = zn();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  Ws(t2, e, n) {
    const s = e.collectionGroup;
    let i = zn();
    return this.indexManager.getCollectionParents(t2, s).next((r) => pi.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new Me(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r2.child(s));
      return this.zs(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  zs(t2, e, n) {
    let s;
    return this.ds.getAllFromCollection(t2, e.path, n).next((n2) => (s = n2, this.Bs.getAllMutationBatchesAffectingQuery(t2, e))).next((t3) => {
      for (const e2 of t3)
        for (const t4 of e2.mutations) {
          const n2 = t4.key;
          let i = s.get(n2);
          i == null && (i = ne.newInvalidDocument(n2), s = s.insert(n2, i)), En(t4, i, e2.localWriteTime), i.isFoundDocument() || (s = s.remove(n2));
        }
    }).next(() => (s.forEach((t3, n2) => {
      He(e, n2) || (s = s.remove(t3));
    }), s));
  }
};
var to = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.Hs = n, this.Js = s;
  }
  static Ys(t2, e) {
    let n = Xn(), s = Xn();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new to(t2, e.fromCache, n, s);
  }
};
var eo = class {
  Xs(t2) {
    this.Zs = t2;
  }
  Qs(t2, e, n, s) {
    return function(t3) {
      return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
    }(e) || n.isEqual(ct.min()) ? this.ti(t2, e) : this.Zs.Ks(t2, s).next((i) => {
      const r = this.ei(e, i);
      return ($e(e) || Be(e)) && this.ni(e.limitType, r, s, n) ? this.ti(t2, e) : (k2() <= LogLevel.DEBUG && O2("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), ze(e)), this.Zs.Qs(t2, e, ae(n, -1)).next((t3) => (r.forEach((e2) => {
        t3 = t3.insert(e2.key, e2);
      }), t3)));
    });
  }
  ei(t2, e) {
    let n = new qn(Ye(t2));
    return e.forEach((e2, s) => {
      He(t2, s) && (n = n.add(s));
    }), n;
  }
  ni(t2, e, n, s) {
    if (n.size !== e.size)
      return true;
    const i = t2 === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  ti(t2, e) {
    return k2() <= LogLevel.DEBUG && O2("QueryEngine", "Using full collection scan to execute query:", ze(e)), this.Zs.Qs(t2, e, he.min());
  }
};
var no = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.si = e, this.M = s, this.ii = new Bn(rt), this.ri = new $n((t3) => _e(t3), me), this.oi = /* @__PURE__ */ new Map(), this.ui = t2.getRemoteDocumentCache(), this.fs = t2.getTargetCache(), this._s = t2.getBundleCache(), this.ai(n);
  }
  ai(t2) {
    this.indexManager = this.persistence.getIndexManager(t2), this.Bs = this.persistence.getMutationQueue(t2, this.indexManager), this.ci = new Zr(this.ui, this.Bs, this.indexManager), this.ui.setIndexManager(this.indexManager), this.si.Xs(this.ci);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.ii));
  }
};
function so(t2, e, n, s) {
  return new no(t2, e, n, s);
}
async function io(t2, e) {
  const n = K2(t2);
  return await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let s;
    return n.Bs.getAllMutationBatches(t3).next((i) => (s = i, n.ai(e), n.Bs.getAllMutationBatches(t3))).next((e2) => {
      const i = [], r = [];
      let o = Xn();
      for (const t4 of s) {
        i.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        r.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return n.ci.Ks(t3, o).next((t4) => ({
        hi: t4,
        removedBatchIds: i,
        addedBatchIds: r
      }));
    });
  });
}
function ro(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.ui.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = pi.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          U2(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && (e3.setReadTime(n2.commitVersion), s2.addEntry(e3)));
        });
      }), o.next(() => t4.Bs.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.Bs.performConsistencyCheck(t3)).next(() => n.ci.Ks(t3, s));
  });
}
function oo(t2) {
  const e = K2(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.fs.getLastRemoteSnapshotVersion(t3));
}
function uo(t2, e) {
  const n = K2(t2), s = e.snapshotVersion;
  let i = n.ii;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.ui.newChangeBuffer({
      trackRemovals: true
    });
    i = n.ii;
    const o = [];
    e.targetChanges.forEach((r2, u2) => {
      const a = i.get(u2);
      if (!a)
        return;
      o.push(n.fs.removeMatchingKeys(t3, r2.removedDocuments, u2).next(() => n.fs.addMatchingKeys(t3, r2.addedDocuments, u2)));
      let c = a.withSequenceNumber(t3.currentSequenceNumber);
      e.targetMismatches.has(u2) ? c = c.withResumeToken(pt.EMPTY_BYTE_STRING, ct.min()).withLastLimboFreeSnapshotVersion(ct.min()) : r2.resumeToken.approximateByteSize() > 0 && (c = c.withResumeToken(r2.resumeToken, s)), i = i.insert(u2, c), function(t4, e2, n2) {
        if (t4.resumeToken.approximateByteSize() === 0)
          return true;
        if (e2.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
          return true;
        return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
      }(a, c, r2) && o.push(n.fs.updateTargetData(t3, c));
    });
    let u = jn();
    if (e.documentUpdates.forEach((s2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(ao(t3, r, e.documentUpdates).next((t4) => {
      u = t4;
    })), !s.isEqual(ct.min())) {
      const e2 = n.fs.getLastRemoteSnapshotVersion(t3).next((e3) => n.fs.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return pi.waitFor(o).next(() => r.apply(t3)).next(() => n.ci.Gs(t3, u)).next(() => u);
  }).then((t3) => (n.ii = i, t3));
}
function ao(t2, e, n) {
  let s = Xn();
  return n.forEach((t3) => s = s.add(t3)), e.getEntries(t2, s).next((t3) => {
    let s2 = jn();
    return n.forEach((n2, i) => {
      const r = t3.get(n2);
      i.isNoDocument() && i.version.isEqual(ct.min()) ? (e.removeEntry(n2, i.readTime), s2 = s2.insert(n2, i)) : !r.isValidDocument() || i.version.compareTo(r.version) > 0 || i.version.compareTo(r.version) === 0 && r.hasPendingWrites ? (e.addEntry(i), s2 = s2.insert(n2, i)) : O2("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", r.version, " Watch version:", i.version);
    }), s2;
  });
}
function co(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n.Bs.getNextMutationBatchAfterBatchId(t3, e)));
}
function ho(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.fs.getTargetData(t3, e).next((i) => i ? (s = i, pi.resolve(s)) : n.fs.allocateTargetId(t3).next((i2) => (s = new ki(e, i2, 0, t3.currentSequenceNumber), n.fs.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.ii.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.ii = n.ii.insert(t3.targetId, t3), n.ri.set(e, t3.targetId)), t3;
  });
}
async function lo(t2, e, n) {
  const s = K2(t2), i = s.ii.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!Ri(t3))
      throw t3;
    O2("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.ii = s.ii.remove(e), s.ri.delete(i.target);
}
function fo(t2, e, n) {
  const s = K2(t2);
  let i = ct.min(), r = Xn();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = K2(t4), i2 = s2.ri.get(n2);
    return i2 !== void 0 ? pi.resolve(s2.ii.get(i2)) : s2.fs.getTargetData(e2, n2);
  }(s, t3, Ge(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.fs.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.si.Qs(t3, e, n ? i : ct.min(), n ? r : Xn())).next((t4) => (mo(s, Je(e), t4), {
    documents: t4,
    li: r
  })));
}
function _o(t2, e) {
  const n = K2(t2), s = K2(n.fs), i = n.ii.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.Et(t3, e).next((t4) => t4 ? t4.target : null));
}
function wo(t2, e) {
  const n = K2(t2), s = n.oi.get(e) || ct.min();
  return n.persistence.runTransaction("Get new document changes", "readonly", (t3) => n.ui.getAllFromCollectionGroup(t3, e, ae(s, -1), Number.MAX_SAFE_INTEGER)).then((t3) => (mo(n, e, t3), t3));
}
function mo(t2, e, n) {
  let s = ct.min();
  n.forEach((t3, e2) => {
    e2.readTime.compareTo(s) > 0 && (s = e2.readTime);
  }), t2.oi.set(e, s);
}
async function go(t2, e, n, s) {
  const i = K2(t2);
  let r = Xn(), o = jn();
  for (const t3 of n) {
    const n2 = e.fi(t3.metadata.name);
    t3.document && (r = r.add(n2));
    const s2 = e.di(t3);
    s2.setReadTime(e._i(t3.metadata.readTime)), o = o.insert(n2, s2);
  }
  const u = i.ui.newChangeBuffer({
    trackRemovals: true
  }), a = await ho(i, function(t3) {
    return Ge(Fe(_t.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => ao(t3, u, o).next((e2) => (u.apply(t3), e2)).next((e2) => i.fs.removeMatchingKeysForTargetId(t3, a.targetId).next(() => i.fs.addMatchingKeys(t3, r, a.targetId)).next(() => i.ci.Gs(t3, e2)).next(() => e2)));
}
async function yo(t2, e, n = Xn()) {
  const s = await ho(t2, Ge(Gi(e.bundledQuery))), i = K2(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = ms(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i._s.saveNamedQuery(t3, e);
    const o = s.withResumeToken(pt.EMPTY_BYTE_STRING, r);
    return i.ii = i.ii.insert(o.targetId, o), i.fs.updateTargetData(t3, o).next(() => i.fs.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.fs.addMatchingKeys(t3, n, s.targetId)).next(() => i._s.saveNamedQuery(t3, e));
  });
}
var po = class {
  constructor(t2) {
    this.M = t2, this.wi = /* @__PURE__ */ new Map(), this.mi = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(t2, e) {
    return pi.resolve(this.wi.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this.wi.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: ms(n.createTime)
    }), pi.resolve();
  }
  getNamedQuery(t2, e) {
    return pi.resolve(this.mi.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.mi.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: Gi(t3.bundledQuery),
        readTime: ms(t3.readTime)
      };
    }(e)), pi.resolve();
  }
};
var Io = class {
  constructor() {
    this.overlays = new Bn(xt.comparator), this.gi = /* @__PURE__ */ new Map();
  }
  getOverlay(t2, e) {
    return pi.resolve(this.overlays.get(e));
  }
  saveOverlays(t2, e, n) {
    return n.forEach((n2, s) => {
      this.Xt(t2, e, s);
    }), pi.resolve();
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = this.gi.get(n);
    return s !== void 0 && (s.forEach((t3) => this.overlays = this.overlays.remove(t3)), this.gi.delete(n)), pi.resolve();
  }
  getOverlaysForCollection(t2, e, n) {
    const s = Hn(), i = e.length + 1, r = new xt(e.child("")), o = this.overlays.getIteratorFrom(r);
    for (; o.hasNext(); ) {
      const t3 = o.getNext().value, r2 = t3.getKey();
      if (!e.isPrefixOf(r2.path))
        break;
      r2.path.length === i && (t3.largestBatchId > n && s.set(t3.getKey(), t3));
    }
    return pi.resolve(s);
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    let i = new Bn((t3, e2) => t3 - e2);
    const r = this.overlays.getIterator();
    for (; r.hasNext(); ) {
      const t3 = r.getNext().value;
      if (t3.getKey().getCollectionGroup() === e && t3.largestBatchId > n) {
        let e2 = i.get(t3.largestBatchId);
        e2 === null && (e2 = Hn(), i = i.insert(t3.largestBatchId, e2)), e2.set(t3.getKey(), t3);
      }
    }
    const o = Hn(), u = i.getIterator();
    for (; u.hasNext(); ) {
      if (u.getNext().value.forEach((t3, e2) => o.set(t3, e2)), o.size() >= s)
        break;
    }
    return pi.resolve(o);
  }
  Xt(t2, e, n) {
    if (n === null)
      return;
    const s = this.overlays.get(n.key);
    if (s !== null) {
      const t3 = this.gi.get(s.largestBatchId).delete(n.key);
      this.gi.set(s.largestBatchId, t3);
    }
    this.overlays = this.overlays.insert(n.key, new Ni(e, n));
    let i = this.gi.get(e);
    i === void 0 && (i = Xn(), this.gi.set(e, i)), this.gi.set(e, i.add(n.key));
  }
};
var To = class {
  constructor() {
    this.yi = new qn(Eo.pi), this.Ii = new qn(Eo.Ti);
  }
  isEmpty() {
    return this.yi.isEmpty();
  }
  addReference(t2, e) {
    const n = new Eo(t2, e);
    this.yi = this.yi.add(n), this.Ii = this.Ii.add(n);
  }
  Ei(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.Ai(new Eo(t2, e));
  }
  Ri(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  Pi(t2) {
    const e = new xt(new _t([])), n = new Eo(e, t2), s = new Eo(e, t2 + 1), i = [];
    return this.Ii.forEachInRange([n, s], (t3) => {
      this.Ai(t3), i.push(t3.key);
    }), i;
  }
  bi() {
    this.yi.forEach((t2) => this.Ai(t2));
  }
  Ai(t2) {
    this.yi = this.yi.delete(t2), this.Ii = this.Ii.delete(t2);
  }
  Vi(t2) {
    const e = new xt(new _t([])), n = new Eo(e, t2), s = new Eo(e, t2 + 1);
    let i = Xn();
    return this.Ii.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new Eo(t2, 0), n = this.yi.firstAfterOrEqual(e);
    return n !== null && t2.isEqual(n.key);
  }
};
var Eo = class {
  constructor(t2, e) {
    this.key = t2, this.vi = e;
  }
  static pi(t2, e) {
    return xt.comparator(t2.key, e.key) || rt(t2.vi, e.vi);
  }
  static Ti(t2, e) {
    return rt(t2.vi, e.vi) || xt.comparator(t2.key, e.key);
  }
};
var Ao = class {
  constructor(t2, e) {
    this.indexManager = t2, this.referenceDelegate = e, this.Bs = [], this.Si = 1, this.Di = new qn(Eo.pi);
  }
  checkEmpty(t2) {
    return pi.resolve(this.Bs.length === 0);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.Si;
    this.Si++, this.Bs.length > 0 && this.Bs[this.Bs.length - 1];
    const r = new Ci(i, e, n, s);
    this.Bs.push(r);
    for (const e2 of s)
      this.Di = this.Di.add(new Eo(e2.key, i)), this.indexManager.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return pi.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return pi.resolve(this.Ci(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this.xi(n), i = s < 0 ? 0 : s;
    return pi.resolve(this.Bs.length > i ? this.Bs[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return pi.resolve(this.Bs.length === 0 ? -1 : this.Si - 1);
  }
  getAllMutationBatches(t2) {
    return pi.resolve(this.Bs.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new Eo(e, 0), s = new Eo(e, Number.POSITIVE_INFINITY), i = [];
    return this.Di.forEachInRange([n, s], (t3) => {
      const e2 = this.Ci(t3.vi);
      i.push(e2);
    }), pi.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new qn(rt);
    return e.forEach((t3) => {
      const e2 = new Eo(t3, 0), s = new Eo(t3, Number.POSITIVE_INFINITY);
      this.Di.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.vi);
      });
    }), pi.resolve(this.Ni(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    xt.isDocumentKey(i) || (i = i.child(""));
    const r = new Eo(new xt(i), 0);
    let o = new qn(rt);
    return this.Di.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.vi)), true);
    }, r), pi.resolve(this.Ni(o));
  }
  Ni(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this.Ci(t3);
      n !== null && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    U2(this.ki(e.batchId, "removed") === 0), this.Bs.shift();
    let n = this.Di;
    return pi.forEach(e.mutations, (s) => {
      const i = new Eo(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.Di = n;
    });
  }
  _n(t2) {
  }
  containsKey(t2, e) {
    const n = new Eo(e, 0), s = this.Di.firstAfterOrEqual(n);
    return pi.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.Bs.length, pi.resolve();
  }
  ki(t2, e) {
    return this.xi(t2);
  }
  xi(t2) {
    if (this.Bs.length === 0)
      return 0;
    return t2 - this.Bs[0].batchId;
  }
  Ci(t2) {
    const e = this.xi(t2);
    if (e < 0 || e >= this.Bs.length)
      return null;
    return this.Bs[e];
  }
};
var Ro = class {
  constructor(t2) {
    this.Mi = t2, this.docs = new Bn(xt.comparator), this.size = 0;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e) {
    const n = e.key, s = this.docs.get(n), i = s ? s.size : 0, r = this.Mi(e);
    return this.docs = this.docs.insert(n, {
      document: e.mutableCopy(),
      size: r
    }), this.size += r - i, this.indexManager.addToCollectionParentIndex(t2, n.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return pi.resolve(n ? n.document.mutableCopy() : ne.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = jn();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.mutableCopy() : ne.newInvalidDocument(t3));
    }), pi.resolve(n);
  }
  getAllFromCollection(t2, e, n) {
    let s = jn();
    const i = new xt(e.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2 } } = r.getNext();
      if (!e.isPrefixOf(t3.path))
        break;
      t3.path.length > e.length + 1 || (le(ce(i2), n) <= 0 || (s = s.insert(i2.key, i2.mutableCopy())));
    }
    return pi.resolve(s);
  }
  getAllFromCollectionGroup(t2, e, n, s) {
    L2();
  }
  Oi(t2, e) {
    return pi.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new Po(this);
  }
  getSize(t2) {
    return pi.resolve(this.size);
  }
};
var Po = class extends $r {
  constructor(t2) {
    super(), this.Kn = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.isValidDocument() ? e.push(this.Kn.addEntry(t2, s)) : this.Kn.removeEntry(n);
    }), pi.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Kn.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.Kn.getEntries(t2, e);
  }
};
var bo = class {
  constructor(t2) {
    this.persistence = t2, this.Fi = new $n((t3) => _e(t3), me), this.lastRemoteSnapshotVersion = ct.min(), this.highestTargetId = 0, this.$i = 0, this.Bi = new To(), this.targetCount = 0, this.Li = br.gn();
  }
  forEachTarget(t2, e) {
    return this.Fi.forEach((t3, n) => e(n)), pi.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return pi.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return pi.resolve(this.$i);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.Li.next(), pi.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.$i && (this.$i = e), pi.resolve();
  }
  Tn(t2) {
    this.Fi.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.Li = new br(e), this.highestTargetId = e), t2.sequenceNumber > this.$i && (this.$i = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.Tn(e), this.targetCount += 1, pi.resolve();
  }
  updateTargetData(t2, e) {
    return this.Tn(e), pi.resolve();
  }
  removeTargetData(t2, e) {
    return this.Fi.delete(e.target), this.Bi.Pi(e.targetId), this.targetCount -= 1, pi.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.Fi.forEach((r, o) => {
      o.sequenceNumber <= e && n.get(o.targetId) === null && (this.Fi.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), pi.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return pi.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.Fi.get(e) || null;
    return pi.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.Bi.Ei(e, n), pi.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.Bi.Ri(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), pi.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.Bi.Pi(e), pi.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.Bi.Vi(e);
    return pi.resolve(n);
  }
  containsKey(t2, e) {
    return pi.resolve(this.Bi.containsKey(e));
  }
};
var Vo = class {
  constructor(t2, e) {
    this.Ui = {}, this.overlays = {}, this.es = new nt(0), this.ns = false, this.ns = true, this.referenceDelegate = t2(this), this.fs = new bo(this);
    this.indexManager = new cr(), this.ds = function(t3) {
      return new Ro(t3);
    }((t3) => this.referenceDelegate.qi(t3)), this.M = new Mi(e), this._s = new po(this.M);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.ns = false, Promise.resolve();
  }
  get started() {
    return this.ns;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(t2) {
    return this.indexManager;
  }
  getDocumentOverlayCache(t2) {
    let e = this.overlays[t2.toKey()];
    return e || (e = new Io(), this.overlays[t2.toKey()] = e), e;
  }
  getMutationQueue(t2, e) {
    let n = this.Ui[t2.toKey()];
    return n || (n = new Ao(e, this.referenceDelegate), this.Ui[t2.toKey()] = n), n;
  }
  getTargetCache() {
    return this.fs;
  }
  getRemoteDocumentCache() {
    return this.ds;
  }
  getBundleCache() {
    return this._s;
  }
  runTransaction(t2, e, n) {
    O2("MemoryPersistence", "Starting transaction:", t2);
    const s = new vo(this.es.next());
    return this.referenceDelegate.Ki(), n(s).next((t3) => this.referenceDelegate.Gi(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Qi(t2, e) {
    return pi.or(Object.values(this.Ui).map((n) => () => n.containsKey(t2, e)));
  }
};
var vo = class extends yi {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var So = class {
  constructor(t2) {
    this.persistence = t2, this.ji = new To(), this.Wi = null;
  }
  static zi(t2) {
    return new So(t2);
  }
  get Hi() {
    if (this.Wi)
      return this.Wi;
    throw L2();
  }
  addReference(t2, e, n) {
    return this.ji.addReference(n, e), this.Hi.delete(n.toString()), pi.resolve();
  }
  removeReference(t2, e, n) {
    return this.ji.removeReference(n, e), this.Hi.add(n.toString()), pi.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.Hi.add(e.toString()), pi.resolve();
  }
  removeTarget(t2, e) {
    this.ji.Pi(e.targetId).forEach((t3) => this.Hi.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.Hi.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  Ki() {
    this.Wi = /* @__PURE__ */ new Set();
  }
  Gi(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return pi.forEach(this.Hi, (n) => {
      const s = xt.fromPath(n);
      return this.Ji(t2, s).next((t3) => {
        t3 || e.removeEntry(s, ct.min());
      });
    }).next(() => (this.Wi = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.Ji(t2, e).next((t3) => {
      t3 ? this.Hi.delete(e.toString()) : this.Hi.add(e.toString());
    });
  }
  qi(t2) {
    return 0;
  }
  Ji(t2, e) {
    return pi.or([() => pi.resolve(this.ji.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Qi(t2, e)]);
  }
};
function Do(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function Co(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function xo(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var No = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static Yi(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r && s.error && (r = typeof s.error.message == "string" && typeof s.error.code == "string", r && (i = new Q2(s.error.code, s.error.message))), r ? new No(t2, e, s.state, i) : (F2("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Xi() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var ko = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static Yi(t2, e) {
    const n = JSON.parse(e);
    let s, i = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
    return i && n.error && (i = typeof n.error.message == "string" && typeof n.error.code == "string", i && (s = new Q2(n.error.code, n.error.message))), i ? new ko(t2, n.state, s) : (F2("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Xi() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Mo = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static Yi(t2, e) {
    const n = JSON.parse(e);
    let s = typeof n == "object" && n.activeTargetIds instanceof Array, i = ts();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = Ct(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new Mo(t2, i) : (F2("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var Oo = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static Yi(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new Oo(e.clientId, e.onlineState) : (F2("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var Fo = class {
  constructor() {
    this.activeTargetIds = ts();
  }
  Zi(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  tr(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Xi() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var $o = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Yn = e, this.persistenceKey = n, this.er = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.nr = this.sr.bind(this), this.ir = new Bn(rt), this.started = false, this.rr = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.ur = Do(this.persistenceKey, this.er), this.ar = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.ir = this.ir.insert(this.er, new Fo()), this.cr = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.hr = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.lr = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.dr = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this._r = function(t3) {
      return `firestore_bundle_loaded_v2_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.nr);
  }
  static vt(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.Fs();
    for (const e2 of t2) {
      if (e2 === this.er)
        continue;
      const t3 = this.getItem(Do(this.persistenceKey, e2));
      if (t3) {
        const n = Mo.Yi(e2, t3);
        n && (this.ir = this.ir.insert(n.clientId, n));
      }
    }
    this.wr();
    const e = this.storage.getItem(this.dr);
    if (e) {
      const t3 = this.mr(e);
      t3 && this.gr(t3);
    }
    for (const t3 of this.rr)
      this.sr(t3);
    this.rr = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.ar, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.yr(this.ir);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.ir.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.pr(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.pr(t2, e, n), this.Ir(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(xo(this.persistenceKey, t2));
      if (n) {
        const s = ko.Yi(t2, n);
        s && (e = s.state);
      }
    }
    return this.Tr.Zi(t2), this.wr(), e;
  }
  removeLocalQueryTarget(t2) {
    this.Tr.tr(t2), this.wr();
  }
  isLocalQueryTarget(t2) {
    return this.Tr.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(xo(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.Er(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.Ir(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.Ar(t2);
  }
  notifyBundleLoaded(t2) {
    this.Rr(t2);
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.nr), this.removeItem(this.ur), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return O2("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    O2("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    O2("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  sr(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if (O2("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.ur)
        return void F2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Yn.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.cr.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.Pr(e.key);
                return this.br(t3, null);
              }
              {
                const t3 = this.Vr(e.key, e.newValue);
                if (t3)
                  return this.br(t3.clientId, t3);
              }
            } else if (this.hr.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.vr(e.key, e.newValue);
                if (t3)
                  return this.Sr(t3);
              }
            } else if (this.lr.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.Dr(e.key, e.newValue);
                if (t3)
                  return this.Cr(t3);
              }
            } else if (e.key === this.dr) {
              if (e.newValue !== null) {
                const t3 = this.mr(e.newValue);
                if (t3)
                  return this.gr(t3);
              }
            } else if (e.key === this.ar) {
              const t3 = function(t4) {
                let e2 = nt.A;
                if (t4 != null)
                  try {
                    const n = JSON.parse(t4);
                    U2(typeof n == "number"), e2 = n;
                  } catch (t5) {
                    F2("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== nt.A && this.sequenceNumberHandler(t3);
            } else if (e.key === this._r) {
              const t3 = this.Nr(e.newValue);
              await Promise.all(t3.map((t4) => this.syncEngine.kr(t4)));
            }
          }
        } else
          this.rr.push(e);
      });
    }
  }
  get Tr() {
    return this.ir.get(this.er);
  }
  wr() {
    this.setItem(this.ur, this.Tr.Xi());
  }
  pr(t2, e, n) {
    const s = new No(this.currentUser, t2, e, n), i = Co(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Xi());
  }
  Ir(t2) {
    const e = Co(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  Ar(t2) {
    const e = {
      clientId: this.er,
      onlineState: t2
    };
    this.storage.setItem(this.dr, JSON.stringify(e));
  }
  Er(t2, e, n) {
    const s = xo(this.persistenceKey, t2), i = new ko(t2, e, n);
    this.setItem(s, i.Xi());
  }
  Rr(t2) {
    const e = JSON.stringify(Array.from(t2));
    this.setItem(this._r, e);
  }
  Pr(t2) {
    const e = this.cr.exec(t2);
    return e ? e[1] : null;
  }
  Vr(t2, e) {
    const n = this.Pr(t2);
    return Mo.Yi(n, e);
  }
  vr(t2, e) {
    const n = this.hr.exec(t2), s = Number(n[1]), i = n[2] !== void 0 ? n[2] : null;
    return No.Yi(new C2(i), s, e);
  }
  Dr(t2, e) {
    const n = this.lr.exec(t2), s = Number(n[1]);
    return ko.Yi(s, e);
  }
  mr(t2) {
    return Oo.Yi(t2);
  }
  Nr(t2) {
    return JSON.parse(t2);
  }
  async Sr(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine.Mr(t2.batchId, t2.state, t2.error);
    O2("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  Cr(t2) {
    return this.syncEngine.Or(t2.targetId, t2.state, t2.error);
  }
  br(t2, e) {
    const n = e ? this.ir.insert(t2, e) : this.ir.remove(t2), s = this.yr(this.ir), i = this.yr(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.Fr(r, o).then(() => {
      this.ir = n;
    });
  }
  gr(t2) {
    this.ir.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  yr(t2) {
    let e = ts();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var Bo = class {
  constructor() {
    this.$r = new Fo(), this.Br = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.$r.Zi(t2), this.Br[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.Br[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.$r.tr(t2);
  }
  isLocalQueryTarget(t2) {
    return this.$r.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.Br[t2];
  }
  getAllActiveQueryTargets() {
    return this.$r.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.$r.activeTargetIds.has(t2);
  }
  start() {
    return this.$r = new Fo(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded(t2) {
  }
};
var Lo = class {
  Lr(t2) {
  }
  shutdown() {
  }
};
var Uo = class {
  constructor() {
    this.Ur = () => this.qr(), this.Kr = () => this.Gr(), this.Qr = [], this.jr();
  }
  Lr(t2) {
    this.Qr.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Ur), window.removeEventListener("offline", this.Kr);
  }
  jr() {
    window.addEventListener("online", this.Ur), window.addEventListener("offline", this.Kr);
  }
  qr() {
    O2("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.Qr)
      t2(0);
  }
  Gr() {
    O2("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.Qr)
      t2(1);
  }
  static vt() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
};
var qo = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var Ko = class {
  constructor(t2) {
    this.Wr = t2.Wr, this.zr = t2.zr;
  }
  Hr(t2) {
    this.Jr = t2;
  }
  Yr(t2) {
    this.Xr = t2;
  }
  onMessage(t2) {
    this.Zr = t2;
  }
  close() {
    this.zr();
  }
  send(t2) {
    this.Wr(t2);
  }
  eo() {
    this.Jr();
  }
  no(t2) {
    this.Xr(t2);
  }
  so(t2) {
    this.Zr(t2);
  }
};
var Go = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.io = e + "://" + t2.host, this.ro = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  oo(t2, e, n, s, i) {
    const r = this.uo(t2, e);
    O2("RestConnection", "Sending: ", r, n);
    const o = {};
    return this.ao(o, s, i), this.co(t2, r, o, n).then((t3) => (O2("RestConnection", "Received: ", t3), t3), (e2) => {
      throw $("RestConnection", `${t2} failed with error: `, e2, "url: ", r, "request:", n), e2;
    });
  }
  ho(t2, e, n, s, i) {
    return this.oo(t2, e, n, s, i);
  }
  ao(t2, e, n) {
    t2["X-Goog-Api-Client"] = "gl-js/ fire/" + x2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e && e.headers.forEach((e2, n2) => t2[n2] = e2), n && n.headers.forEach((e2, n2) => t2[n2] = e2);
  }
  uo(t2, e) {
    const n = qo[t2];
    return `${this.io}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  co(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              O2("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              O2("Connection", 'RPC "' + t2 + '" timed out'), r(new Q2(G.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if (O2("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(G).indexOf(e4) >= 0 ? e4 : G.UNKNOWN;
                  }(t3.status);
                  r(new Q2(e3, t3.message));
                } else
                  r(new Q2(G.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new Q2(G.UNAVAILABLE, "Connection failed."));
              break;
            default:
              L2();
          }
        } finally {
          O2("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const u = JSON.stringify(s);
      o.send(e, "POST", u, n, 15);
    });
  }
  lo(t2, e, n) {
    const s = [this.io, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], i = createWebChannelTransport(), r = getStatEventTarget(), o = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (o.xmlHttpFactory = new FetchXmlHttpFactory({})), this.ao(o.initMessageHeaders, e, n), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (o.httpHeadersOverwriteParam = "$httpHeaders");
    const u = s.join("");
    O2("Connection", "Creating WebChannel: " + u, o);
    const a = i.createWebChannel(u, o);
    let c = false, h = false;
    const l2 = new Ko({
      Wr: (t3) => {
        h ? O2("Connection", "Not sending because WebChannel is closed:", t3) : (c || (O2("Connection", "Opening WebChannel transport."), a.open(), c = true), O2("Connection", "WebChannel sending:", t3), a.send(t3));
      },
      zr: () => a.close()
    }), y2 = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return y2(a, WebChannel.EventType.OPEN, () => {
      h || O2("Connection", "WebChannel transport opened.");
    }), y2(a, WebChannel.EventType.CLOSE, () => {
      h || (h = true, O2("Connection", "WebChannel transport closed"), l2.no());
    }), y2(a, WebChannel.EventType.ERROR, (t3) => {
      h || (h = true, $("Connection", "WebChannel transport errored:", t3), l2.no(new Q2(G.UNAVAILABLE, "The operation could not be completed")));
    }), y2(a, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!h) {
        const n2 = t3.data[0];
        U2(!!n2);
        const s2 = n2, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          O2("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = kn[t5];
            if (e4 !== void 0)
              return Fn(e4);
          }(t4), n3 = i2.message;
          e3 === void 0 && (e3 = G.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), h = true, l2.no(new Q2(e3, n3)), a.close();
        } else
          O2("Connection", "WebChannel received:", n2), l2.so(n2);
      }
    }), y2(r, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? O2("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && O2("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      l2.eo();
    }, 0), l2;
  }
};
function Qo() {
  return typeof window != "undefined" ? window : null;
}
function jo() {
  return typeof document != "undefined" ? document : null;
}
function Wo(t2) {
  return new fs(t2, true);
}
var zo = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Yn = t2, this.timerId = e, this.fo = n, this._o = s, this.wo = i, this.mo = 0, this.yo = null, this.po = Date.now(), this.reset();
  }
  reset() {
    this.mo = 0;
  }
  Io() {
    this.mo = this.wo;
  }
  To(t2) {
    this.cancel();
    const e = Math.floor(this.mo + this.Eo()), n = Math.max(0, Date.now() - this.po), s = Math.max(0, e - n);
    s > 0 && O2("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.mo} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.yo = this.Yn.enqueueAfterDelay(this.timerId, s, () => (this.po = Date.now(), t2())), this.mo *= this._o, this.mo < this.fo && (this.mo = this.fo), this.mo > this.wo && (this.mo = this.wo);
  }
  Ao() {
    this.yo !== null && (this.yo.skipDelay(), this.yo = null);
  }
  cancel() {
    this.yo !== null && (this.yo.cancel(), this.yo = null);
  }
  Eo() {
    return (Math.random() - 0.5) * this.mo;
  }
};
var Ho = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.Yn = t2, this.Ro = n, this.Po = s, this.bo = i, this.authCredentialsProvider = r, this.appCheckCredentialsProvider = o, this.listener = u, this.state = 0, this.Vo = 0, this.vo = null, this.So = null, this.stream = null, this.Do = new zo(t2, e);
  }
  Co() {
    return this.state === 1 || this.state === 5 || this.xo();
  }
  xo() {
    return this.state === 2 || this.state === 3;
  }
  start() {
    this.state !== 4 ? this.auth() : this.No();
  }
  async stop() {
    this.Co() && await this.close(0);
  }
  ko() {
    this.state = 0, this.Do.reset();
  }
  Mo() {
    this.xo() && this.vo === null && (this.vo = this.Yn.enqueueAfterDelay(this.Ro, 6e4, () => this.Oo()));
  }
  Fo(t2) {
    this.$o(), this.stream.send(t2);
  }
  async Oo() {
    if (this.xo())
      return this.close(0);
  }
  $o() {
    this.vo && (this.vo.cancel(), this.vo = null);
  }
  Bo() {
    this.So && (this.So.cancel(), this.So = null);
  }
  async close(t2, e) {
    this.$o(), this.Bo(), this.Do.cancel(), this.Vo++, t2 !== 4 ? this.Do.reset() : e && e.code === G.RESOURCE_EXHAUSTED ? (F2(e.toString()), F2("Using maximum backoff delay to prevent overloading the backend."), this.Do.Io()) : e && e.code === G.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.Lo(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Yr(e);
  }
  Lo() {
  }
  auth() {
    this.state = 1;
    const t2 = this.Uo(this.Vo), e = this.Vo;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t3, n]) => {
      this.Vo === e && this.qo(t3, n);
    }, (e2) => {
      t2(() => {
        const t3 = new Q2(G.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.Ko(t3);
      });
    });
  }
  qo(t2, e) {
    const n = this.Uo(this.Vo);
    this.stream = this.Go(t2, e), this.stream.Hr(() => {
      n(() => (this.state = 2, this.So = this.Yn.enqueueAfterDelay(this.Po, 1e4, () => (this.xo() && (this.state = 3), Promise.resolve())), this.listener.Hr()));
    }), this.stream.Yr((t3) => {
      n(() => this.Ko(t3));
    }), this.stream.onMessage((t3) => {
      n(() => this.onMessage(t3));
    });
  }
  No() {
    this.state = 5, this.Do.To(async () => {
      this.state = 0, this.start();
    });
  }
  Ko(t2) {
    return O2("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(4, t2);
  }
  Uo(t2) {
    return (e) => {
      this.Yn.enqueueAndForget(() => this.Vo === t2 ? e() : (O2("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var Jo = class extends Ho {
  constructor(t2, e, n, s, i, r) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, n, s, r), this.M = i;
  }
  Go(t2, e) {
    return this.bo.lo("Listen", t2, e);
  }
  onMessage(t2) {
    this.Do.reset();
    const e = vs(this.M, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return ct.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? ct.min() : e2.readTime ? ms(e2.readTime) : ct.min();
    }(t2);
    return this.listener.Qo(e, n);
  }
  jo(t2) {
    const e = {};
    e.database = As(this.M), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = ge(s) ? {
        documents: xs(t3, s)
      } : {
        query: Ns(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = _s(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(ct.min()) > 0 && (n2.readTime = ds(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.M, t2);
    const n = Ms(this.M, t2);
    n && (e.labels = n), this.Fo(e);
  }
  Wo(t2) {
    const e = {};
    e.database = As(this.M), e.removeTarget = t2, this.Fo(e);
  }
};
var Yo = class extends Ho {
  constructor(t2, e, n, s, i, r) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, s, r), this.M = i, this.zo = false;
  }
  get Ho() {
    return this.zo;
  }
  start() {
    this.zo = false, this.lastStreamToken = void 0, super.start();
  }
  Lo() {
    this.zo && this.Jo([]);
  }
  Go(t2, e) {
    return this.bo.lo("Write", t2, e);
  }
  onMessage(t2) {
    if (U2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.zo) {
      this.Do.reset();
      const e = Cs(t2.writeResults, t2.commitTime), n = ms(t2.commitTime);
      return this.listener.Yo(n, e);
    }
    return U2(!t2.writeResults || t2.writeResults.length === 0), this.zo = true, this.listener.Xo();
  }
  Zo() {
    const t2 = {};
    t2.database = As(this.M), this.Fo(t2);
  }
  Jo(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => Ss(this.M, t3))
    };
    this.Fo(e);
  }
};
var Xo = class extends class {
} {
  constructor(t2, e, n, s) {
    super(), this.authCredentials = t2, this.appCheckCredentials = e, this.bo = n, this.M = s, this.tu = false;
  }
  eu() {
    if (this.tu)
      throw new Q2(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  oo(t2, e, n) {
    return this.eu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.bo.oo(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q2(G.UNKNOWN, t3.toString());
    });
  }
  ho(t2, e, n) {
    return this.eu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.bo.ho(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q2(G.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.tu = true;
  }
};
var Zo = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.nu = 0, this.su = null, this.iu = true;
  }
  ru() {
    this.nu === 0 && (this.ou("Unknown"), this.su = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.su = null, this.uu("Backend didn't respond within 10 seconds."), this.ou("Offline"), Promise.resolve())));
  }
  au(t2) {
    this.state === "Online" ? this.ou("Unknown") : (this.nu++, this.nu >= 1 && (this.cu(), this.uu(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.ou("Offline")));
  }
  set(t2) {
    this.cu(), this.nu = 0, t2 === "Online" && (this.iu = false), this.ou(t2);
  }
  ou(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  uu(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.iu ? (F2(e), this.iu = false) : O2("OnlineStateTracker", e);
  }
  cu() {
    this.su !== null && (this.su.cancel(), this.su = null);
  }
};
var tu = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.hu = [], this.lu = /* @__PURE__ */ new Map(), this.fu = /* @__PURE__ */ new Set(), this.du = [], this._u = i, this._u.Lr((t3) => {
      n.enqueueAndForget(async () => {
        cu(this) && (O2("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = K2(t4);
          e2.fu.add(4), await nu(e2), e2.wu.set("Unknown"), e2.fu.delete(4), await eu(e2);
        }(this));
      });
    }), this.wu = new Zo(n, s);
  }
};
async function eu(t2) {
  if (cu(t2))
    for (const e of t2.du)
      await e(true);
}
async function nu(t2) {
  for (const e of t2.du)
    await e(false);
}
function su(t2, e) {
  const n = K2(t2);
  n.lu.has(e.targetId) || (n.lu.set(e.targetId, e), au(n) ? uu(n) : Vu(n).xo() && ru(n, e));
}
function iu(t2, e) {
  const n = K2(t2), s = Vu(n);
  n.lu.delete(e), s.xo() && ou(n, e), n.lu.size === 0 && (s.xo() ? s.Mo() : cu(n) && n.wu.set("Unknown"));
}
function ru(t2, e) {
  t2.mu.Z(e.targetId), Vu(t2).jo(e);
}
function ou(t2, e) {
  t2.mu.Z(e), Vu(t2).Wo(e);
}
function uu(t2) {
  t2.mu = new us({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    Et: (e) => t2.lu.get(e) || null
  }), Vu(t2).start(), t2.wu.ru();
}
function au(t2) {
  return cu(t2) && !Vu(t2).Co() && t2.lu.size > 0;
}
function cu(t2) {
  return K2(t2).fu.size === 0;
}
function hu(t2) {
  t2.mu = void 0;
}
async function lu(t2) {
  t2.lu.forEach((e, n) => {
    ru(t2, e);
  });
}
async function fu(t2, e) {
  hu(t2), au(t2) ? (t2.wu.au(e), uu(t2)) : t2.wu.set("Unknown");
}
async function du(t2, e, n) {
  if (t2.wu.set("Online"), e instanceof rs && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.lu.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.lu.delete(s), t3.mu.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      O2("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await _u(t2, n2);
    }
  else if (e instanceof ss ? t2.mu.ut(e) : e instanceof is ? t2.mu._t(e) : t2.mu.ht(e), !n.isEqual(ct.min()))
    try {
      const e2 = await oo(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.mu.yt(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.lu.get(s);
            i && t3.lu.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.lu.get(e4);
          if (!n3)
            return;
          t3.lu.set(e4, n3.withResumeToken(pt.EMPTY_BYTE_STRING, n3.snapshotVersion)), ou(t3, e4);
          const s = new ki(n3.target, e4, 1, n3.sequenceNumber);
          ru(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      O2("RemoteStore", "Failed to raise snapshot:", e2), await _u(t2, e2);
    }
}
async function _u(t2, e, n) {
  if (!Ri(e))
    throw e;
  t2.fu.add(1), await nu(t2), t2.wu.set("Offline"), n || (n = () => oo(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    O2("RemoteStore", "Retrying IndexedDB access"), await n(), t2.fu.delete(1), await eu(t2);
  });
}
function wu(t2, e) {
  return e().catch((n) => _u(t2, n, e));
}
async function mu(t2) {
  const e = K2(t2), n = vu(e);
  let s = e.hu.length > 0 ? e.hu[e.hu.length - 1].batchId : -1;
  for (; gu(e); )
    try {
      const t3 = await co(e.localStore, s);
      if (t3 === null) {
        e.hu.length === 0 && n.Mo();
        break;
      }
      s = t3.batchId, yu(e, t3);
    } catch (t3) {
      await _u(e, t3);
    }
  pu(e) && Iu(e);
}
function gu(t2) {
  return cu(t2) && t2.hu.length < 10;
}
function yu(t2, e) {
  t2.hu.push(e);
  const n = vu(t2);
  n.xo() && n.Ho && n.Jo(e.mutations);
}
function pu(t2) {
  return cu(t2) && !vu(t2).Co() && t2.hu.length > 0;
}
function Iu(t2) {
  vu(t2).start();
}
async function Tu(t2) {
  vu(t2).Zo();
}
async function Eu(t2) {
  const e = vu(t2);
  for (const n of t2.hu)
    e.Jo(n.mutations);
}
async function Au(t2, e, n) {
  const s = t2.hu.shift(), i = xi.from(s, e, n);
  await wu(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await mu(t2);
}
async function Ru(t2, e) {
  e && vu(t2).Ho && await async function(t3, e2) {
    if (n = e2.code, On(n) && n !== G.ABORTED) {
      const n2 = t3.hu.shift();
      vu(t3).ko(), await wu(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await mu(t3);
    }
    var n;
  }(t2, e), pu(t2) && Iu(t2);
}
async function Pu(t2, e) {
  const n = K2(t2);
  n.asyncQueue.verifyOperationInProgress(), O2("RemoteStore", "RemoteStore received new credentials");
  const s = cu(n);
  n.fu.add(3), await nu(n), s && n.wu.set("Unknown"), await n.remoteSyncer.handleCredentialChange(e), n.fu.delete(3), await eu(n);
}
async function bu(t2, e) {
  const n = K2(t2);
  e ? (n.fu.delete(2), await eu(n)) : e || (n.fu.add(2), await nu(n), n.wu.set("Unknown"));
}
function Vu(t2) {
  return t2.gu || (t2.gu = function(t3, e, n) {
    const s = K2(t3);
    return s.eu(), new Jo(e, s.bo, s.authCredentials, s.appCheckCredentials, s.M, n);
  }(t2.datastore, t2.asyncQueue, {
    Hr: lu.bind(null, t2),
    Yr: fu.bind(null, t2),
    Qo: du.bind(null, t2)
  }), t2.du.push(async (e) => {
    e ? (t2.gu.ko(), au(t2) ? uu(t2) : t2.wu.set("Unknown")) : (await t2.gu.stop(), hu(t2));
  })), t2.gu;
}
function vu(t2) {
  return t2.yu || (t2.yu = function(t3, e, n) {
    const s = K2(t3);
    return s.eu(), new Yo(e, s.bo, s.authCredentials, s.appCheckCredentials, s.M, n);
  }(t2.datastore, t2.asyncQueue, {
    Hr: Tu.bind(null, t2),
    Yr: Ru.bind(null, t2),
    Xo: Eu.bind(null, t2),
    Yo: Au.bind(null, t2)
  }), t2.du.push(async (e) => {
    e ? (t2.yu.ko(), await mu(t2)) : (await t2.yu.stop(), t2.hu.length > 0 && (O2("RemoteStore", `Stopping write stream with ${t2.hu.length} pending writes`), t2.hu = []));
  })), t2.yu;
}
var Su = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new j(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new Su(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new Q2(G.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function Du(t2, e) {
  if (F2("AsyncQueue", `${e}: ${t2}`), Ri(t2))
    return new Q2(G.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var Cu = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || xt.comparator(e.key, n.key) : (t3, e) => xt.comparator(t3.key, e.key), this.keyedMap = zn(), this.sortedSet = new Bn(this.comparator);
  }
  static emptySet(t2) {
    return new Cu(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof Cu))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new Cu();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var xu = class {
  constructor() {
    this.pu = new Bn(xt.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.pu.get(e);
    n ? t2.type !== 0 && n.type === 3 ? this.pu = this.pu.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.pu = this.pu.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 2 ? this.pu = this.pu.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 0 ? this.pu = this.pu.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n.type === 0 ? this.pu = this.pu.remove(e) : t2.type === 1 && n.type === 2 ? this.pu = this.pu.insert(e, {
      type: 1,
      doc: n.doc
    }) : t2.type === 0 && n.type === 1 ? this.pu = this.pu.insert(e, {
      type: 2,
      doc: t2.doc
    }) : L2() : this.pu = this.pu.insert(e, t2);
  }
  Iu() {
    const t2 = [];
    return this.pu.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var Nu = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = u;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new Nu(t2, e, Cu.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && je(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var ku = class {
  constructor() {
    this.Tu = void 0, this.listeners = [];
  }
};
var Mu = class {
  constructor() {
    this.queries = new $n((t2) => We(t2), je), this.onlineState = "Unknown", this.Eu = /* @__PURE__ */ new Set();
  }
};
async function Ou(t2, e) {
  const n = K2(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new ku()), i)
    try {
      r.Tu = await n.onListen(s);
    } catch (t3) {
      const n2 = Du(t3, `Initialization of query '${ze(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.Au(n.onlineState), r.Tu) {
    e.Ru(r.Tu) && Lu(n);
  }
}
async function Fu(t2, e) {
  const n = K2(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function $u(t2, e) {
  const n = K2(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.Ru(t3) && (s = true);
      i.Tu = t3;
    }
  }
  s && Lu(n);
}
function Bu(t2, e, n) {
  const s = K2(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function Lu(t2) {
  t2.Eu.forEach((t3) => {
    t3.next();
  });
}
var Uu = class {
  constructor(t2, e, n) {
    this.query = t2, this.Pu = e, this.bu = false, this.Vu = null, this.onlineState = "Unknown", this.options = n || {};
  }
  Ru(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        n.type !== 3 && e2.push(n);
      t2 = new Nu(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.bu ? this.vu(t2) && (this.Pu.next(t2), e = true) : this.Su(t2, this.onlineState) && (this.Du(t2), e = true), this.Vu = t2, e;
  }
  onError(t2) {
    this.Pu.error(t2);
  }
  Au(t2) {
    this.onlineState = t2;
    let e = false;
    return this.Vu && !this.bu && this.Su(this.Vu, t2) && (this.Du(this.Vu), e = true), e;
  }
  Su(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = e !== "Offline";
    return (!this.options.Cu || !n) && (!t2.docs.isEmpty() || e === "Offline");
  }
  vu(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.Vu && this.Vu.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  Du(t2) {
    t2 = Nu.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.bu = true, this.Pu.next(t2);
  }
};
var qu = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  xu() {
    return "metadata" in this.payload;
  }
};
var Ku = class {
  constructor(t2) {
    this.M = t2;
  }
  fi(t2) {
    return Is(this.M, t2);
  }
  di(t2) {
    return t2.metadata.exists ? bs(this.M, t2.document, false) : ne.newNoDocument(this.fi(t2.metadata.name), this._i(t2.metadata.readTime));
  }
  _i(t2) {
    return ms(t2);
  }
};
var Gu = class {
  constructor(t2, e, n) {
    this.Nu = t2, this.localStore = e, this.M = n, this.queries = [], this.documents = [], this.collectionGroups = /* @__PURE__ */ new Set(), this.progress = Qu(t2);
  }
  ku(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    if (t2.payload.namedQuery)
      this.queries.push(t2.payload.namedQuery);
    else if (t2.payload.documentMetadata) {
      this.documents.push({
        metadata: t2.payload.documentMetadata
      }), t2.payload.documentMetadata.exists || ++e;
      const n = _t.fromString(t2.payload.documentMetadata.name);
      this.collectionGroups.add(n.get(n.length - 2));
    } else
      t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e);
    return e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  Mu(t2) {
    const e = /* @__PURE__ */ new Map(), n = new Ku(this.M);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.fi(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || Xn()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await go(this.localStore, new Ku(this.M), this.documents, this.Nu.id), e = this.Mu(this.documents);
    for (const t3 of this.queries)
      await yo(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", {
      progress: this.progress,
      Ou: this.collectionGroups,
      Fu: t2
    };
  }
};
function Qu(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var ju = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Wu = class {
  constructor(t2) {
    this.key = t2;
  }
};
var zu = class {
  constructor(t2, e) {
    this.query = t2, this.$u = e, this.Bu = null, this.current = false, this.Lu = Xn(), this.mutatedKeys = Xn(), this.Uu = Ye(t2), this.qu = new Cu(this.Uu);
  }
  get Ku() {
    return this.$u;
  }
  Gu(t2, e) {
    const n = e ? e.Qu : new xu(), s = e ? e.qu : this.qu;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const u = $e(this.query) && s.size === this.query.limit ? s.last() : null, a = Be(this.query) && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const c = s.get(t3), h = He(this.query, e2) ? e2 : null, l2 = !!c && this.mutatedKeys.has(c.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (c && h) {
        c.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.ju(c, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (u && this.Uu(h, u) > 0 || a && this.Uu(h, a) < 0) && (o = true));
      } else
        !c && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : c && !h && (n.track({
          type: 1,
          doc: c
        }), d = true, (u || a) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), $e(this.query) || Be(this.query))
      for (; r.size > this.query.limit; ) {
        const t3 = $e(this.query) ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      qu: r,
      Qu: n,
      ni: o,
      mutatedKeys: i
    };
  }
  ju(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.qu;
    this.qu = t2.qu, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.Qu.Iu();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return L2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.Uu(t3.doc, e2.doc)), this.Wu(n);
    const r = e ? this.zu() : [], o = this.Lu.size === 0 && this.current ? 1 : 0, u = o !== this.Bu;
    if (this.Bu = o, i.length !== 0 || u) {
      return {
        snapshot: new Nu(this.query, t2.qu, s, i, t2.mutatedKeys, o === 0, u, false),
        Hu: r
      };
    }
    return {
      Hu: r
    };
  }
  Au(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      qu: this.qu,
      Qu: new xu(),
      mutatedKeys: this.mutatedKeys,
      ni: false
    }, false)) : {
      Hu: []
    };
  }
  Ju(t2) {
    return !this.$u.has(t2) && (!!this.qu.has(t2) && !this.qu.get(t2).hasLocalMutations);
  }
  Wu(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.$u = this.$u.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.$u = this.$u.delete(t3)), this.current = t2.current);
  }
  zu() {
    if (!this.current)
      return [];
    const t2 = this.Lu;
    this.Lu = Xn(), this.qu.forEach((t3) => {
      this.Ju(t3.key) && (this.Lu = this.Lu.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.Lu.has(t3) || e.push(new Wu(t3));
    }), this.Lu.forEach((n) => {
      t2.has(n) || e.push(new ju(n));
    }), e;
  }
  Yu(t2) {
    this.$u = t2.li, this.Lu = Xn();
    const e = this.Gu(t2.documents);
    return this.applyChanges(e, true);
  }
  Xu() {
    return Nu.fromInitialDocuments(this.query, this.qu, this.mutatedKeys, this.Bu === 0);
  }
};
var Hu = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var Ju = class {
  constructor(t2) {
    this.key = t2, this.Zu = false;
  }
};
var Yu = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.ta = {}, this.ea = new $n((t3) => We(t3), je), this.na = /* @__PURE__ */ new Map(), this.sa = /* @__PURE__ */ new Set(), this.ia = new Bn(xt.comparator), this.ra = /* @__PURE__ */ new Map(), this.oa = new To(), this.ua = {}, this.aa = /* @__PURE__ */ new Map(), this.ca = br.yn(), this.onlineState = "Unknown", this.ha = void 0;
  }
  get isPrimaryClient() {
    return this.ha === true;
  }
};
async function Xu(t2, e) {
  const n = Va2(t2);
  let s, i;
  const r = n.ea.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.Xu();
  else {
    const t3 = await ho(n.localStore, Ge(e));
    n.isPrimaryClient && su(n.remoteStore, t3);
    const r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await Zu(n, e, s, r2 === "current");
  }
  return i;
}
async function Zu(t2, e, n, s) {
  t2.la = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.Gu(n3);
    i2.ni && (i2 = await fo(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view.Gu(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return fa2(t3, e3.targetId, o2.Hu), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await fo(t2.localStore, e, true), r = new zu(e, i.li), o = r.Gu(i.documents), u = ns.createSynthesizedTargetChangeForCurrentChange(n, s && t2.onlineState !== "Offline"), a = r.applyChanges(o, t2.isPrimaryClient, u);
  fa2(t2, n, a.Hu);
  const c = new Hu(e, n, r);
  return t2.ea.set(e, c), t2.na.has(n) ? t2.na.get(n).push(e) : t2.na.set(n, [e]), a.snapshot;
}
async function ta2(t2, e) {
  const n = K2(t2), s = n.ea.get(e), i = n.na.get(s.targetId);
  if (i.length > 1)
    return n.na.set(s.targetId, i.filter((t3) => !je(t3, e))), void n.ea.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await lo(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), iu(n.remoteStore, s.targetId), ha2(n, s.targetId);
    }).catch(Cr);
  } else
    ha2(n, s.targetId), await lo(n.localStore, s.targetId, true);
}
async function ea2(t2, e, n) {
  const s = va(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = K2(t4), s2 = at.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), Xn());
      let r;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n2.ci.Ks(t5, i).next((i2) => {
        r = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = An(t6, r.get(t6.key));
          e3 != null && o.push(new Vn(t6.key, e3, ee(e3.value.mapValue), yn.exists(true)));
        }
        return n2.Bs.addMutationBatch(t5, s2, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r), {
        batchId: t5.batchId,
        changes: r
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.ua[t4.currentUser.toKey()];
      s2 || (s2 = new Bn(rt));
      s2 = s2.insert(e2, n2), t4.ua[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await wa(s, t3.changes), await mu(s.remoteStore);
  } catch (t3) {
    const e2 = Du(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function na2(t2, e) {
  const n = K2(t2);
  try {
    const t3 = await uo(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.ra.get(e2);
      s && (U2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.Zu = true : t4.modifiedDocuments.size > 0 ? U2(s.Zu) : t4.removedDocuments.size > 0 && (U2(s.Zu), s.Zu = false));
    }), await wa(n, t3, e);
  } catch (t3) {
    await Cr(t3);
  }
}
function sa2(t2, e, n) {
  const s = K2(t2);
  if (s.isPrimaryClient && n === 0 || !s.isPrimaryClient && n === 1) {
    const t3 = [];
    s.ea.forEach((n2, s2) => {
      const i = s2.view.Au(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = K2(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.Au(e2) && (s2 = true);
      }), s2 && Lu(n2);
    }(s.eventManager, e), t3.length && s.ta.Qo(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function ia2(t2, e, n) {
  const s = K2(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.ra.get(e), r = i && i.key;
  if (r) {
    let t3 = new Bn(xt.comparator);
    t3 = t3.insert(r, ne.newNoDocument(r, ct.min()));
    const n2 = Xn().add(r), i2 = new es(ct.min(), /* @__PURE__ */ new Map(), new qn(rt), t3, n2);
    await na2(s, i2), s.ia = s.ia.remove(r), s.ra.delete(e), _a(s);
  } else
    await lo(s.localStore, e, false).then(() => ha2(s, e, n)).catch(Cr);
}
async function ra2(t2, e) {
  const n = K2(t2), s = e.batch.batchId;
  try {
    const t3 = await ro(n.localStore, e);
    ca(n, s, null), aa2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await wa(n, t3);
  } catch (t3) {
    await Cr(t3);
  }
}
async function oa2(t2, e, n) {
  const s = K2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = K2(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.Bs.lookupMutationBatch(t5, e2).next((e3) => (U2(e3 !== null), s2 = e3.keys(), n2.Bs.removeMutationBatch(t5, e3))).next(() => n2.Bs.performConsistencyCheck(t5)).next(() => n2.ci.Ks(t5, s2));
      });
    }(s.localStore, e);
    ca(s, e, n), aa2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await wa(s, t3);
  } catch (n2) {
    await Cr(n2);
  }
}
async function ua2(t2, e) {
  const n = K2(t2);
  cu(n.remoteStore) || O2("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = K2(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.Bs.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n.aa.get(t3) || [];
    s.push(e), n.aa.set(t3, s);
  } catch (t3) {
    const n2 = Du(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function aa2(t2, e) {
  (t2.aa.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.aa.delete(e);
}
function ca(t2, e, n) {
  const s = K2(t2);
  let i = s.ua[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.ua[s.currentUser.toKey()] = i;
  }
}
function ha2(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.na.get(e))
    t2.ea.delete(s), n && t2.ta.fa(s, n);
  if (t2.na.delete(e), t2.isPrimaryClient) {
    t2.oa.Pi(e).forEach((e2) => {
      t2.oa.containsKey(e2) || la2(t2, e2);
    });
  }
}
function la2(t2, e) {
  t2.sa.delete(e.path.canonicalString());
  const n = t2.ia.get(e);
  n !== null && (iu(t2.remoteStore, n), t2.ia = t2.ia.remove(e), t2.ra.delete(n), _a(t2));
}
function fa2(t2, e, n) {
  for (const s of n)
    if (s instanceof ju)
      t2.oa.addReference(s.key, e), da2(t2, s);
    else if (s instanceof Wu) {
      O2("SyncEngine", "Document no longer in limbo: " + s.key), t2.oa.removeReference(s.key, e);
      t2.oa.containsKey(s.key) || la2(t2, s.key);
    } else
      L2();
}
function da2(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.ia.get(n) || t2.sa.has(s) || (O2("SyncEngine", "New document in limbo: " + n), t2.sa.add(s), _a(t2));
}
function _a(t2) {
  for (; t2.sa.size > 0 && t2.ia.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.sa.values().next().value;
    t2.sa.delete(e);
    const n = new xt(_t.fromString(e)), s = t2.ca.next();
    t2.ra.set(s, new Ju(n)), t2.ia = t2.ia.insert(n, s), su(t2.remoteStore, new ki(Ge(Fe(n.path)), s, 2, nt.A));
  }
}
async function wa(t2, e, n) {
  const s = K2(t2), i = [], r = [], o = [];
  s.ea.isEmpty() || (s.ea.forEach((t3, u) => {
    o.push(s.la(u, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(u.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = to.Ys(u.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.ta.Qo(i), await async function(t3, e2) {
    const n2 = K2(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => pi.forEach(e2, (e3) => pi.forEach(e3.Hs, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => pi.forEach(e3.Js, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!Ri(t4))
        throw t4;
      O2("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.ii.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.ii = n2.ii.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function ma2(t2, e) {
  const n = K2(t2);
  if (!n.currentUser.isEqual(e)) {
    O2("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await io(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.aa.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new Q2(G.CANCELLED, e2));
        });
      }), t4.aa.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await wa(n, t3.hi);
  }
}
function ga(t2, e) {
  const n = K2(t2), s = n.ra.get(e);
  if (s && s.Zu)
    return Xn().add(s.key);
  {
    let t3 = Xn();
    const s2 = n.na.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.ea.get(e2);
      t3 = t3.unionWith(s3.view.Ku);
    }
    return t3;
  }
}
async function ya2(t2, e) {
  const n = K2(t2), s = await fo(n.localStore, e.query, true), i = e.view.Yu(s);
  return n.isPrimaryClient && fa2(n, e.targetId, i.Hu), i;
}
async function pa2(t2, e) {
  const n = K2(t2);
  return wo(n.localStore, e).then((t3) => wa(n, t3));
}
async function Ia2(t2, e, n, s) {
  const i = K2(t2), r = await function(t3, e2) {
    const n2 = K2(t3), s2 = K2(n2.Bs);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.fn(t4, e2).next((e3) => e3 ? n2.ci.Ks(t4, e3) : pi.resolve(null)));
  }(i.localStore, e);
  r !== null ? (n === "pending" ? await mu(i.remoteStore) : n === "acknowledged" || n === "rejected" ? (ca(i, e, s || null), aa2(i, e), function(t3, e2) {
    K2(K2(t3).Bs)._n(e2);
  }(i.localStore, e)) : L2(), await wa(i, r)) : O2("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function Ta(t2, e) {
  const n = K2(t2);
  if (Va2(n), va(n), e === true && n.ha !== true) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await Ea(n, t3.toArray());
    n.ha = true, await bu(n.remoteStore, true);
    for (const t4 of e2)
      su(n.remoteStore, t4);
  } else if (e === false && n.ha !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.na.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (ha2(n, i), lo(n.localStore, i, true))), iu(n.remoteStore, i);
    }), await e2, await Ea(n, t3), function(t4) {
      const e3 = K2(t4);
      e3.ra.forEach((t5, n2) => {
        iu(e3.remoteStore, n2);
      }), e3.oa.bi(), e3.ra = /* @__PURE__ */ new Map(), e3.ia = new Bn(xt.comparator);
    }(n), n.ha = false, await bu(n.remoteStore, false);
  }
}
async function Ea(t2, e, n) {
  const s = K2(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.na.get(t3);
    if (n2 && n2.length !== 0) {
      e2 = await ho(s.localStore, Ge(n2[0]));
      for (const t4 of n2) {
        const e3 = s.ea.get(t4), n3 = await ya2(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await _o(s.localStore, t3);
      e2 = await ho(s.localStore, n3), await Zu(s, Aa2(n3), t3, false);
    }
    i.push(e2);
  }
  return s.ta.Qo(r), i;
}
function Aa2(t2) {
  return Oe(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function Ra2(t2) {
  const e = K2(t2);
  return K2(K2(e.localStore).persistence).Fs();
}
async function Pa(t2, e, n, s) {
  const i = K2(t2);
  if (i.ha)
    return void O2("SyncEngine", "Ignoring unexpected query state notification.");
  const r = i.na.get(e);
  if (r && r.length > 0)
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await wo(i.localStore, Je(r[0])), s2 = es.createSynthesizedRemoteEventForCurrentChange(e, n === "current");
        await wa(i, t3, s2);
        break;
      }
      case "rejected":
        await lo(i.localStore, e, true), ha2(i, e, s);
        break;
      default:
        L2();
    }
}
async function ba2(t2, e, n) {
  const s = Va2(t2);
  if (s.ha) {
    for (const t3 of e) {
      if (s.na.has(t3)) {
        O2("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await _o(s.localStore, t3), n2 = await ho(s.localStore, e2);
      await Zu(s, Aa2(e2), n2.targetId, false), su(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.na.has(t3) && await lo(s.localStore, t3, false).then(() => {
        iu(s.remoteStore, t3), ha2(s, t3);
      }).catch(Cr);
  }
}
function Va2(t2) {
  const e = K2(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = na2.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = ga.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = ia2.bind(null, e), e.ta.Qo = $u.bind(null, e.eventManager), e.ta.fa = Bu.bind(null, e.eventManager), e;
}
function va(t2) {
  const e = K2(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = ra2.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = oa2.bind(null, e), e;
}
function Sa2(t2, e, n) {
  const s = K2(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = K2(t4), s3 = ms(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3._s.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2)), Promise.resolve(/* @__PURE__ */ new Set());
      n2._updateProgress(Qu(s2));
      const i = new Gu(s2, t3.localStore, e2.M);
      let r = await e2.da();
      for (; r; ) {
        const t4 = await i.ku(r);
        t4 && n2._updateProgress(t4), r = await e2.da();
      }
      const o = await i.complete();
      return await wa(t3, o.Fu, void 0), await function(t4, e3) {
        const n3 = K2(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3._s.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress), Promise.resolve(o.Ou);
    } catch (t4) {
      return $("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4), Promise.resolve(/* @__PURE__ */ new Set());
    }
  })(s, e, n).then((t3) => {
    s.sharedClientState.notifyBundleLoaded(t3);
  });
}
var Da = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.M = Wo(t2.databaseInfo.databaseId), this.sharedClientState = this._a(t2), this.persistence = this.wa(t2), await this.persistence.start(), this.gcScheduler = this.ma(t2), this.localStore = this.ga(t2);
  }
  ma(t2) {
    return null;
  }
  ga(t2) {
    return so(this.persistence, new eo(), t2.initialUser, this.M);
  }
  wa(t2) {
    return new Vo(So.zi, this.M);
  }
  _a(t2) {
    return new Bo();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var Ca2 = class extends Da {
  constructor(t2, e, n) {
    super(), this.ya = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await this.ya.initialize(this, t2), await va(this.ya.syncEngine), await mu(this.ya.remoteStore), await this.persistence.Ts(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(this.localStore), Promise.resolve()));
  }
  ga(t2) {
    return so(this.persistence, new eo(), t2.initialUser, this.M);
  }
  ma(t2) {
    const e = this.persistence.referenceDelegate.garbageCollector;
    return new kr(e, t2.asyncQueue);
  }
  wa(t2) {
    const e = Xr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = this.cacheSizeBytes !== void 0 ? yr.withCacheSize(this.cacheSizeBytes) : yr.DEFAULT;
    return new Hr(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, Qo(), jo(), this.M, this.sharedClientState, !!this.forceOwnership);
  }
  _a(t2) {
    return new Bo();
  }
};
var xa2 = class extends Ca2 {
  constructor(t2, e) {
    super(t2, e, false), this.ya = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.ya.syncEngine;
    this.sharedClientState instanceof $o && (this.sharedClientState.syncEngine = {
      Mr: Ia2.bind(null, e),
      Or: Pa.bind(null, e),
      Fr: ba2.bind(null, e),
      Fs: Ra2.bind(null, e),
      kr: pa2.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.Ts(async (t3) => {
      await Ta(this.ya.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t3 || this.gcScheduler.stop());
    });
  }
  _a(t2) {
    const e = Qo();
    if (!$o.vt(e))
      throw new Q2(G.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = Xr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new $o(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var Na2 = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => sa2(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = ma2.bind(null, this.syncEngine), await bu(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new Mu();
  }
  createDatastore(t2) {
    const e = Wo(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new Go(s));
    var s;
    return function(t3, e2, n2, s2) {
      return new Xo(t3, e2, n2, s2);
    }(t2.authCredentials, t2.appCheckCredentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => sa2(this.syncEngine, t3, 0), r = Uo.vt() ? new Uo() : new Lo(), new tu(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const u = new Yu(t3, e2, n, s, i, r);
      return o && (u.ha = true), u;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = K2(t2);
      O2("RemoteStore", "RemoteStore shutting down."), e.fu.add(5), await nu(e), e._u.shutdown(), e.wu.set("Unknown");
    }(this.remoteStore);
  }
};
function ka2(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var Ma2 = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.pa(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.pa(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  Ia() {
    this.muted = true;
  }
  pa(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var Oa = class {
  constructor(t2, e) {
    this.Ta = t2, this.M = e, this.metadata = new j(), this.buffer = new Uint8Array(), this.Ea = new TextDecoder("utf-8"), this.Aa().then((t3) => {
      t3 && t3.xu() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.Ta.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async da() {
    return await this.getMetadata(), this.Aa();
  }
  async Aa() {
    const t2 = await this.Ra();
    if (t2 === null)
      return null;
    const e = this.Ea.decode(t2), n = Number(e);
    isNaN(n) && this.Pa(`length string (${e}) is not valid number`);
    const s = await this.ba(n);
    return new qu(JSON.parse(s), t2.length + n);
  }
  Va() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async Ra() {
    for (; this.Va() < 0; ) {
      if (await this.va())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.Va();
    t2 < 0 && this.Pa("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async ba(t2) {
    for (; this.buffer.length < t2; ) {
      await this.va() && this.Pa("Reached the end of bundle when more is expected.");
    }
    const e = this.Ea.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  Pa(t2) {
    throw this.Ta.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async va() {
    const t2 = await this.Ta.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var Fa2 = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new Q2(G.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = K2(t3), s = As(n.M) + "/documents", i = {
        documents: e2.map((t4) => ps(n.M, t4))
      }, r = await n.ho("BatchGetDocuments", s, i), o = /* @__PURE__ */ new Map();
      r.forEach((t4) => {
        const e3 = Vs(n.M, t4);
        o.set(e3.key.toString(), e3);
      });
      const u = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        U2(!!e3), u.push(e3);
      }), u;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new Cn(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = xt.fromPath(e);
      this.mutations.push(new xn(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = K2(t3), s = As(n.M) + "/documents", i = {
        writes: e.map((t4) => Ss(n.M, t4))
      };
      await n.oo("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw L2();
      e = ct.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new Q2(G.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? yn.updateTime(e) : yn.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(ct.min()))
        throw new Q2(G.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return yn.updateTime(e);
    }
    return yn.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var $a2 = class {
  constructor(t2, e, n, s) {
    this.asyncQueue = t2, this.datastore = e, this.updateFunction = n, this.deferred = s, this.Sa = 5, this.Do = new zo(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.Sa -= 1, this.Da();
  }
  Da() {
    this.Do.To(async () => {
      const t2 = new Fa2(this.datastore), e = this.Ca(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.xa(t3);
        }));
      }).catch((t3) => {
        this.xa(t3);
      });
    });
  }
  Ca(t2) {
    try {
      const e = this.updateFunction(t2);
      return !St(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  xa(t2) {
    this.Sa > 0 && this.Na(t2) ? (this.Sa -= 1, this.asyncQueue.enqueueAndForget(() => (this.Da(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  Na(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !On(e);
    }
    return false;
  }
};
var Ba = class {
  constructor(t2, e, n, s) {
    this.authCredentials = t2, this.appCheckCredentials = e, this.asyncQueue = n, this.databaseInfo = s, this.user = C2.UNAUTHENTICATED, this.clientId = it.R(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async (t3) => {
      O2("FirestoreClient", "Received user=", t3.uid), await this.authCredentialListener(t3), this.user = t3;
    }), this.appCheckCredentials.start(n, (t3) => (O2("FirestoreClient", "Received new app check token=", t3), this.appCheckCredentialListener(t3, this.user)));
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.authCredentialListener = t2;
  }
  setAppCheckTokenChangeListener(t2) {
    this.appCheckCredentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new Q2(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new j();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = Du(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function La2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), O2("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await io(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function Ua2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await qa2(t2);
  O2("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => Pu(e.remoteStore, t3)), t2.setAppCheckTokenChangeListener((t3, n2) => Pu(e.remoteStore, n2)), t2.onlineComponents = e;
}
async function qa2(t2) {
  return t2.offlineComponents || (O2("FirestoreClient", "Using default OfflineComponentProvider"), await La2(t2, new Da())), t2.offlineComponents;
}
async function Ka2(t2) {
  return t2.onlineComponents || (O2("FirestoreClient", "Using default OnlineComponentProvider"), await Ua2(t2, new Na2())), t2.onlineComponents;
}
function Ga2(t2) {
  return qa2(t2).then((t3) => t3.persistence);
}
function Qa(t2) {
  return qa2(t2).then((t3) => t3.localStore);
}
function ja2(t2) {
  return Ka2(t2).then((t3) => t3.remoteStore);
}
function Wa2(t2) {
  return Ka2(t2).then((t3) => t3.syncEngine);
}
async function za2(t2) {
  const e = await Ka2(t2), n = e.eventManager;
  return n.onListen = Xu.bind(null, e.syncEngine), n.onUnlisten = ta2.bind(null, e.syncEngine), n;
}
function Ha2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Ga2(t2), n = await ja2(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = K2(t3);
      return e2.fu.delete(0), eu(e2);
    }(n);
  });
}
function Ja2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Ga2(t2), n = await ja2(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = K2(t3);
      e2.fu.add(0), await nu(e2), e2.wu.set("Offline");
    }(n);
  });
}
function Ya2(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = K2(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.ci.Ls(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new Q2(G.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = Du(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await Qa(t2), e, n)), n.promise;
}
function Xa2(t2, e, n = {}) {
  const s = new j();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Ma2({
      next: (r2) => {
        e2.enqueueAndForget(() => Fu(t3, o));
        const u = r2.docs.has(n2);
        !u && r2.fromCache ? i.reject(new Q2(G.UNAVAILABLE, "Failed to get document because the client is offline.")) : u && r2.fromCache && s2 && s2.source === "server" ? i.reject(new Q2(G.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new Uu(Fe(n2.path), r, {
      includeMetadataChanges: true,
      Cu: true
    });
    return Ou(t3, o);
  }(await za2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function Za2(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await fo(t3, e2, true), i = new zu(e2, s.li), r = i.Gu(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = Du(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await Qa(t2), e, n)), n.promise;
}
function tc2(t2, e, n = {}) {
  const s = new j();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Ma2({
      next: (n3) => {
        e2.enqueueAndForget(() => Fu(t3, o)), n3.fromCache && s2.source === "server" ? i.reject(new Q2(G.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new Uu(n2, r, {
      includeMetadataChanges: true,
      Cu: true
    });
    return Ou(t3, o);
  }(await za2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function ec2(t2, e) {
  const n = new Ma2(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    K2(t3).Eu.add(e2), e2.next();
  }(await za2(t2), n)), () => {
    n.Ia(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      K2(t3).Eu.delete(e2);
    }(await za2(t2), n));
  };
}
function nc2(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const s = await function(t3) {
      return Ka2(t3).then((t4) => t4.datastore);
    }(t2);
    new $a2(t2.asyncQueue, s, e, n).run();
  }), n.promise;
}
function sc2(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new Oa(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return ka2(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return ka2(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, Wo(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    Sa2(await Wa2(t2), i, s);
  });
}
function ic2(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = K2(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n._s.getNamedQuery(t4, e2));
  }(await Qa(t2), e));
}
var rc2 = /* @__PURE__ */ new Map();
function oc2(t2, e, n) {
  if (!n)
    throw new Q2(G.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function uc2(t2, e, n, s) {
  if (e === true && s === true)
    throw new Q2(G.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function ac2(t2) {
  if (!xt.isDocumentKey(t2))
    throw new Q2(G.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function cc2(t2) {
  if (xt.isDocumentKey(t2))
    throw new Q2(G.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function hc2(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : L2();
}
function lc2(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new Q2(G.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = hc2(t2);
      throw new Q2(G.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function fc2(t2, e) {
  if (e <= 0)
    throw new Q2(G.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var dc2 = class {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new Q2(G.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new Q2(G.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, uc2("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var _c = class {
  constructor(t2, e, n) {
    this._authCredentials = e, this._appCheckCredentials = n, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new dc2({}), this._settingsFrozen = false, t2 instanceof vt ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new Q2(G.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new vt(t3.options.projectId);
    }(t2));
  }
  get app() {
    if (!this._app)
      throw new Q2(G.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new Q2(G.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new dc2(t2), t2.credentials !== void 0 && (this._authCredentials = function(t3) {
      if (!t3)
        return new z2();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return U2(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new X2(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new Q2(G.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = rc2.get(t2);
      e && (O2("ComponentProvider", "Removing Datastore"), rc2.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function wc2(t2, e, n, s = {}) {
  var i;
  const r = (t2 = lc2(t2, _c))._getSettings();
  if (r.host !== "firestore.googleapis.com" && r.host !== e && $("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if (typeof s.mockUserToken == "string")
      e2 = s.mockUserToken, n2 = C2.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, (i = t2._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new Q2(G.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new C2(r2);
    }
    t2._authCredentials = new H2(new W2(e2, n2));
  }
}
var mc2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new yc2(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new mc2(this.firestore, t2, this._key);
  }
};
var gc2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new gc2(this.firestore, t2, this._query);
  }
};
var yc2 = class extends gc2 {
  constructor(t2, e, n) {
    super(t2, e, Fe(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new mc2(this.firestore, null, new xt(t2));
  }
  withConverter(t2) {
    return new yc2(this.firestore, t2, this._path);
  }
};
function pc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), oc2("collection", "path", e), t2 instanceof _c) {
    const s = _t.fromString(e, ...n);
    return cc2(s), new yc2(t2, null, s);
  }
  {
    if (!(t2 instanceof mc2 || t2 instanceof yc2))
      throw new Q2(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(_t.fromString(e, ...n));
    return cc2(s), new yc2(t2.firestore, null, s);
  }
}
function Ic2(t2, e) {
  if (t2 = lc2(t2, _c), oc2("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new Q2(G.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new gc2(t2, null, function(t3) {
    return new Me(_t.emptyPath(), t3);
  }(e));
}
function Tc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = it.R()), oc2("doc", "path", e), t2 instanceof _c) {
    const s = _t.fromString(e, ...n);
    return ac2(s), new mc2(t2, null, new xt(s));
  }
  {
    if (!(t2 instanceof mc2 || t2 instanceof yc2))
      throw new Q2(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(_t.fromString(e, ...n));
    return ac2(s), new mc2(t2.firestore, t2 instanceof yc2 ? t2.converter : null, new xt(s));
  }
}
function Ec2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof mc2 || t2 instanceof yc2) && (e instanceof mc2 || e instanceof yc2) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function Ac2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof gc2 && e instanceof gc2 && (t2.firestore === e.firestore && je(t2._query, e._query) && t2.converter === e.converter);
}
var Rc2 = class {
  constructor() {
    this.ka = Promise.resolve(), this.Ma = [], this.Oa = false, this.Fa = [], this.$a = null, this.Ba = false, this.La = false, this.Ua = [], this.Do = new zo(this, "async_queue_retry"), this.qa = () => {
      const t3 = jo();
      t3 && O2("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.Do.Ao();
    };
    const t2 = jo();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.qa);
  }
  get isShuttingDown() {
    return this.Oa;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Ka(), this.Ga(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.Oa) {
      this.Oa = true, this.La = t2 || false;
      const e = jo();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.qa);
    }
  }
  enqueue(t2) {
    if (this.Ka(), this.Oa)
      return new Promise(() => {
      });
    const e = new j();
    return this.Ga(() => this.Oa && this.La ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.Ma.push(t2), this.Qa()));
  }
  async Qa() {
    if (this.Ma.length !== 0) {
      try {
        await this.Ma[0](), this.Ma.shift(), this.Do.reset();
      } catch (t2) {
        if (!Ri(t2))
          throw t2;
        O2("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.Ma.length > 0 && this.Do.To(() => this.Qa());
    }
  }
  Ga(t2) {
    const e = this.ka.then(() => (this.Ba = true, t2().catch((t3) => {
      this.$a = t3, this.Ba = false;
      const e2 = function(t4) {
        let e3 = t4.message || "";
        t4.stack && (e3 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e3;
      }(t3);
      throw F2("INTERNAL UNHANDLED ERROR: ", e2), t3;
    }).then((t3) => (this.Ba = false, t3))));
    return this.ka = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.Ka(), this.Ua.indexOf(t2) > -1 && (e = 0);
    const s = Su.createAndSchedule(this, t2, e, n, (t3) => this.ja(t3));
    return this.Fa.push(s), s;
  }
  Ka() {
    this.$a && L2();
  }
  verifyOperationInProgress() {
  }
  async Wa() {
    let t2;
    do {
      t2 = this.ka, await t2;
    } while (t2 !== this.ka);
  }
  za(t2) {
    for (const e of this.Fa)
      if (e.timerId === t2)
        return true;
    return false;
  }
  Ha(t2) {
    return this.Wa().then(() => {
      this.Fa.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this.Fa)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.Wa();
    });
  }
  Ja(t2) {
    this.Ua.push(t2);
  }
  ja(t2) {
    const e = this.Fa.indexOf(t2);
    this.Fa.splice(e, 1);
  }
};
function Pc2(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var bc2 = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new j(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var Vc2 = -1;
var vc2 = class extends _c {
  constructor(t2, e, n) {
    super(t2, e, n), this.type = "firestore", this._queue = new Rc2(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || xc2(this), this._firestoreClient.terminate();
  }
};
function Cc2(t2) {
  return t2._firestoreClient || xc2(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function xc2(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new Vt(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new Ba(t2._authCredentials, t2._appCheckCredentials, t2._queue, s);
}
function Nc2(t2, e) {
  Kc2(t2 = lc2(t2, vc2));
  const n = Cc2(t2), s = t2._freezeSettings(), i = new Na2();
  return Mc2(n, i, new Ca2(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function kc2(t2) {
  Kc2(t2 = lc2(t2, vc2));
  const e = Cc2(t2), n = t2._freezeSettings(), s = new Na2();
  return Mc2(e, s, new xa2(s, n.cacheSizeBytes));
}
function Mc2(t2, e, n) {
  const s = new j();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await La2(t2, n), await Ua2(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === G.FAILED_PRECONDITION || t4.code === G.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function Oc2(t2) {
  if (t2._initialized && !t2._terminated)
    throw new Q2(G.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new j();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!Ti.vt())
          return Promise.resolve();
        const e2 = t3 + "main";
        await Ti.delete(e2);
      }(Xr(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function Fc2(t2) {
  return function(t3) {
    const e = new j();
    return t3.asyncQueue.enqueueAndForget(async () => ua2(await Wa2(t3), e)), e.promise;
  }(Cc2(t2 = lc2(t2, vc2)));
}
function $c2(t2) {
  return Ha2(Cc2(t2 = lc2(t2, vc2)));
}
function Bc2(t2) {
  return Ja2(Cc2(t2 = lc2(t2, vc2)));
}
function Uc2(t2, e) {
  const n = Cc2(t2 = lc2(t2, vc2)), s = new bc2();
  return sc2(n, t2._databaseId, e, s), s;
}
function qc2(t2, e) {
  return ic2(Cc2(t2 = lc2(t2, vc2)), e).then((e2) => e2 ? new gc2(t2, null, e2.query) : null);
}
function Kc2(t2) {
  if (t2._initialized || t2._terminated)
    throw new Q2(G.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var Gc2 = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new Q2(G.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new mt(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
var jc2 = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new jc2(pt.fromBase64String(t2));
    } catch (t3) {
      throw new Q2(G.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new jc2(pt.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var Wc2 = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var zc2 = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new Q2(G.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new Q2(G.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return rt(this._lat, t2._lat) || rt(this._long, t2._long);
  }
};
var Hc2 = /^__.*__$/;
var Jc2 = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new Vn(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new bn(t2, this.data, e, this.fieldTransforms);
  }
};
var Yc2 = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new Vn(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function Xc2(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw L2();
  }
}
var Zc2 = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.M = n, this.ignoreUndefinedProperties = s, i === void 0 && this.Ya(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get Xa() {
    return this.settings.Xa;
  }
  Za(t2) {
    return new Zc2(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.M, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  tc(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Za({
      path: n,
      ec: false
    });
    return s.nc(t2), s;
  }
  sc(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Za({
      path: n,
      ec: false
    });
    return s.Ya(), s;
  }
  ic(t2) {
    return this.Za({
      path: void 0,
      ec: true
    });
  }
  rc(t2) {
    return ph(t2, this.settings.methodName, this.settings.oc || false, this.path, this.settings.uc);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  Ya() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.nc(this.path.get(t2));
  }
  nc(t2) {
    if (t2.length === 0)
      throw this.rc("Document fields must not be empty");
    if (Xc2(this.Xa) && Hc2.test(t2))
      throw this.rc('Document fields cannot begin and end with "__"');
  }
};
var th = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.M = n || Wo(t2);
  }
  ac(t2, e, n, s = false) {
    return new Zc2({
      Xa: t2,
      methodName: e,
      uc: n,
      path: mt.emptyPath(),
      ec: false,
      oc: s
    }, this.databaseId, this.M, this.ignoreUndefinedProperties);
  }
};
function eh(t2) {
  const e = t2._freezeSettings(), n = Wo(t2._databaseId);
  return new th(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function nh(t2, e, n, s, i, r = {}) {
  const o = t2.ac(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  wh("Data must be an object, but it was:", o, s);
  const u = dh(s, o);
  let a, c;
  if (r.merge)
    a = new gt(o.fieldMask), c = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = mh(e, s2, n);
      if (!o.contains(i2))
        throw new Q2(G.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      Ih(t3, i2) || t3.push(i2);
    }
    a = new gt(t3), c = o.fieldTransforms.filter((t4) => a.covers(t4.field));
  } else
    a = null, c = o.fieldTransforms;
  return new Jc2(new te(u), a, c);
}
var sh = class extends Wc2 {
  _toFieldTransform(t2) {
    if (t2.Xa !== 2)
      throw t2.Xa === 1 ? t2.rc(`${this._methodName}() can only appear at the top level of your update data`) : t2.rc(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof sh;
  }
};
function ih(t2, e, n) {
  return new Zc2({
    Xa: 3,
    uc: e.settings.uc,
    methodName: t2._methodName,
    ec: n
  }, e.databaseId, e.M, e.ignoreUndefinedProperties);
}
var rh = class extends Wc2 {
  _toFieldTransform(t2) {
    return new wn(t2.path, new un());
  }
  isEqual(t2) {
    return t2 instanceof rh;
  }
};
var oh = class extends Wc2 {
  constructor(t2, e) {
    super(t2), this.cc = e;
  }
  _toFieldTransform(t2) {
    const e = ih(this, t2, true), n = this.cc.map((t3) => fh(t3, e)), s = new an(n);
    return new wn(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var uh = class extends Wc2 {
  constructor(t2, e) {
    super(t2), this.cc = e;
  }
  _toFieldTransform(t2) {
    const e = ih(this, t2, true), n = this.cc.map((t3) => fh(t3, e)), s = new hn(n);
    return new wn(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var ah = class extends Wc2 {
  constructor(t2, e) {
    super(t2), this.hc = e;
  }
  _toFieldTransform(t2) {
    const e = new fn(t2.M, en(t2.M, this.hc));
    return new wn(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function ch(t2, e, n, s) {
  const i = t2.ac(1, e, n);
  wh("Data must be an object, but it was:", i, s);
  const r = [], o = te.empty();
  lt(s, (t3, s2) => {
    const u2 = yh(e, t3, n);
    s2 = getModularInstance(s2);
    const a = i.sc(u2);
    if (s2 instanceof sh)
      r.push(u2);
    else {
      const t4 = fh(s2, a);
      t4 != null && (r.push(u2), o.set(u2, t4));
    }
  });
  const u = new gt(r);
  return new Yc2(o, u, i.fieldTransforms);
}
function hh(t2, e, n, s, i, r) {
  const o = t2.ac(1, e, n), u = [mh(e, s, n)], a = [i];
  if (r.length % 2 != 0)
    throw new Q2(G.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    u.push(mh(e, r[t3])), a.push(r[t3 + 1]);
  const c = [], h = te.empty();
  for (let t3 = u.length - 1; t3 >= 0; --t3)
    if (!Ih(c, u[t3])) {
      const e2 = u[t3];
      let n2 = a[t3];
      n2 = getModularInstance(n2);
      const s2 = o.sc(e2);
      if (n2 instanceof sh)
        c.push(e2);
      else {
        const t4 = fh(n2, s2);
        t4 != null && (c.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new gt(c);
  return new Yc2(h, l2, o.fieldTransforms);
}
function lh(t2, e, n, s = false) {
  return fh(n, t2.ac(s ? 4 : 3, e));
}
function fh(t2, e) {
  if (_h(t2 = getModularInstance(t2)))
    return wh("Unsupported field value:", e, t2), dh(t2, e);
  if (t2 instanceof Wc2)
    return function(t3, e2) {
      if (!Xc2(e2.Xa))
        throw e2.rc(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.rc(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.ec && e.Xa !== 4)
      throw e.rc("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = fh(i, e2.ic(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return en(e2.M, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = at.fromDate(t3);
      return {
        timestampValue: ds(e2.M, n)
      };
    }
    if (t3 instanceof at) {
      const n = new at(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: ds(e2.M, n)
      };
    }
    if (t3 instanceof zc2)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof jc2)
      return {
        bytesValue: _s(e2.M, t3._byteString)
      };
    if (t3 instanceof mc2) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.rc(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: gs(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.rc(`Unsupported field value: ${hc2(t3)}`);
  }(t2, e);
}
function dh(t2, e) {
  const n = {};
  return ft(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : lt(t2, (t3, s) => {
    const i = fh(s, e.tc(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function _h(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof at || t2 instanceof zc2 || t2 instanceof jc2 || t2 instanceof mc2 || t2 instanceof Wc2);
}
function wh(t2, e, n) {
  if (!_h(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s = hc2(n);
    throw s === "an object" ? e.rc(t2 + " a custom object") : e.rc(t2 + " " + s);
  }
}
function mh(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof Gc2)
    return e._internalPath;
  if (typeof e == "string")
    return yh(t2, e);
  throw ph("Field path arguments must be of type string or ", t2, false, void 0, n);
}
var gh = new RegExp("[~\\*/\\[\\]]");
function yh(t2, e, n) {
  if (e.search(gh) >= 0)
    throw ph(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new Gc2(...e.split("."))._internalPath;
  } catch (s) {
    throw ph(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function ph(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = i !== void 0;
  let u = `Function ${e}() called with invalid data`;
  n && (u += " (via `toFirestore()`)"), u += ". ";
  let a = "";
  return (r || o) && (a += " (found", r && (a += ` in field ${s}`), o && (a += ` in document ${i}`), a += ")"), new Q2(G.INVALID_ARGUMENT, u + t2 + a);
}
function Ih(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var Th = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new mc2(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new Eh(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(Ah("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var Eh = class extends Th {
  data() {
    return super.data();
  }
};
function Ah(t2, e) {
  return typeof e == "string" ? yh(t2, e) : e instanceof Gc2 ? e._internalPath : e._delegate._internalPath;
}
var Rh = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var Ph = class extends Th {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new bh(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(Ah("DocumentSnapshot.get", t2));
      if (n !== null)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var bh = class extends Ph {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var Vh = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new Rh(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new bh(this._firestore, this._userDataWriter, n.key, n, new Rh(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new Q2(G.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new bh(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new Rh(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new bh(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new Rh(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: vh(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function vh(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return L2();
  }
}
function Sh(t2, e) {
  return t2 instanceof Ph && e instanceof Ph ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof Vh && e instanceof Vh && (t2._firestore === e._firestore && Ac2(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function Dh(t2) {
  if (Be(t2) && t2.explicitOrderBy.length === 0)
    throw new Q2(G.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Ch = class {
};
function xh(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var Nh = class extends Ch {
  constructor(t2, e, n) {
    super(), this.lc = t2, this.fc = e, this.dc = n, this.type = "where";
  }
  _apply(t2) {
    const e = eh(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let u;
      if (i.isKeyField()) {
        if (r === "array-contains" || r === "array-contains-any")
          throw new Q2(G.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on documentId().`);
        if (r === "in" || r === "not-in") {
          zh(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(Wh(s, t3, n3));
          u = {
            arrayValue: {
              values: e3
            }
          };
        } else
          u = Wh(s, t3, o);
      } else
        r !== "in" && r !== "not-in" && r !== "array-contains-any" || zh(o, r), u = lh(n2, e2, o, r === "in" || r === "not-in");
      const a = Te.create(i, r, u);
      return function(t4, e3) {
        if (e3.S()) {
          const n4 = Ue(t4);
          if (n4 !== null && !n4.isEqual(e3.field))
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = Le(t4);
          s2 !== null && Hh(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n3 !== null)
          throw n3 === e3.op ? new Q2(G.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new Q2(G.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, a), a;
    }(t2._query, "where", e, t2.firestore._databaseId, this.lc, this.fc, this.dc);
    return new gc2(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new Me(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function kh(t2, e, n) {
  const s = e, i = Ah("where", t2);
  return new Nh(i, s, n);
}
var Mh = class extends Ch {
  constructor(t2, e) {
    super(), this.lc = t2, this._c = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (t3.startAt !== null)
        throw new Q2(G.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new Q2(G.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new Ce(e2, n);
      return function(t4, e3) {
        if (Le(t4) === null) {
          const n2 = Ue(t4);
          n2 !== null && Hh(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.lc, this._c);
    return new gc2(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new Me(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function Oh(t2, e = "asc") {
  const n = e, s = Ah("orderBy", t2);
  return new Mh(s, n);
}
var Fh = class extends Ch {
  constructor(t2, e, n) {
    super(), this.type = t2, this.wc = e, this.mc = n;
  }
  _apply(t2) {
    return new gc2(t2.firestore, t2.converter, Qe(t2._query, this.wc, this.mc));
  }
};
function $h(t2) {
  return fc2("limit", t2), new Fh("limit", t2, "F");
}
function Bh(t2) {
  return fc2("limitToLast", t2), new Fh("limitToLast", t2, "L");
}
var Lh = class extends Ch {
  constructor(t2, e, n) {
    super(), this.type = t2, this.gc = e, this.yc = n;
  }
  _apply(t2) {
    const e = jh(t2, this.type, this.gc, this.yc);
    return new gc2(t2.firestore, t2.converter, function(t3, e2) {
      return new Me(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function Uh(...t2) {
  return new Lh("startAt", t2, true);
}
function qh(...t2) {
  return new Lh("startAfter", t2, false);
}
var Kh = class extends Ch {
  constructor(t2, e, n) {
    super(), this.type = t2, this.gc = e, this.yc = n;
  }
  _apply(t2) {
    const e = jh(t2, this.type, this.gc, this.yc);
    return new gc2(t2.firestore, t2.converter, function(t3, e2) {
      return new Me(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function Gh(...t2) {
  return new Kh("endBefore", t2, false);
}
function Qh(...t2) {
  return new Kh("endAt", t2, true);
}
function jh(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof Th)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new Q2(G.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of Ke(t3))
        if (n3.field.isKeyField())
          r.push(qt(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (Rt(t4))
            throw new Q2(G.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n3.field.canonicalString();
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new De(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = eh(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new Q2(G.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const u = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const a = i2[r2];
        if (o[r2].field.isKeyField()) {
          if (typeof a != "string")
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof a}`);
          if (!qe(t3) && a.indexOf("/") !== -1)
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${s2}() must be a plain document ID, but '${a}' contains a slash.`);
          const n3 = t3.path.child(_t.fromString(a));
          if (!xt.isDocumentKey(n3))
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new xt(n3);
          u.push(qt(e2, i3));
        } else {
          const t4 = lh(n2, s2, a);
          u.push(t4);
        }
      }
      return new De(u, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function Wh(t2, e, n) {
  if (typeof (n = getModularInstance(n)) == "string") {
    if (n === "")
      throw new Q2(G.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!qe(e) && n.indexOf("/") !== -1)
      throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(_t.fromString(n));
    if (!xt.isDocumentKey(s))
      throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return qt(t2, new xt(s));
  }
  if (n instanceof mc2)
    return qt(t2, n._key);
  throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${hc2(n)}.`);
}
function zh(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new Q2(G.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new Q2(G.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function Hh(t2, e, n) {
  if (!n.isEqual(e))
    throw new Q2(G.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var Jh = class {
  convertValue(t2, e = "none") {
    switch (Mt(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return Et(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(At(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw L2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return lt(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new zc2(Et(t2.latitude), Et(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = Pt(t2);
        return n == null ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(bt(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = Tt(t2);
    return new at(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = _t.fromString(t2);
    U2(Gs(n));
    const s = new vt(n.get(1), n.get(3)), i = new xt(n.popFirst(5));
    return s.isEqual(e) || F2(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function Yh(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var Xh = class extends Jh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new jc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new mc2(this.firestore, null, e);
  }
};
var Zh = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = eh(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = tl(t2, this._firestore), i = Yh(s.converter, e, n), r = nh(this._dataReader, "WriteBatch.set", s._key, i, s.converter !== null, n);
    return this._mutations.push(r.toMutation(s._key, yn.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = tl(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Gc2 ? hh(this._dataReader, "WriteBatch.update", i._key, e, n, s) : ch(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, yn.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = tl(t2, this._firestore);
    return this._mutations = this._mutations.concat(new Cn(e._key, yn.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new Q2(G.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function tl(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new Q2(G.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function el(t2) {
  t2 = lc2(t2, mc2);
  const e = lc2(t2.firestore, vc2);
  return Xa2(Cc2(e), t2._key).then((n) => wl(e, t2, n));
}
var nl = class extends Jh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new jc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new mc2(this.firestore, null, e);
  }
};
function sl(t2) {
  t2 = lc2(t2, mc2);
  const e = lc2(t2.firestore, vc2), n = Cc2(e), s = new nl(e);
  return Ya2(n, t2._key).then((n2) => new Ph(e, s, t2._key, n2, new Rh(n2 !== null && n2.hasLocalMutations, true), t2.converter));
}
function il(t2) {
  t2 = lc2(t2, mc2);
  const e = lc2(t2.firestore, vc2);
  return Xa2(Cc2(e), t2._key, {
    source: "server"
  }).then((n) => wl(e, t2, n));
}
function rl(t2) {
  t2 = lc2(t2, gc2);
  const e = lc2(t2.firestore, vc2), n = Cc2(e), s = new nl(e);
  return Dh(t2._query), tc2(n, t2._query).then((n2) => new Vh(e, s, t2, n2));
}
function ol(t2) {
  t2 = lc2(t2, gc2);
  const e = lc2(t2.firestore, vc2), n = Cc2(e), s = new nl(e);
  return Za2(n, t2._query).then((n2) => new Vh(e, s, t2, n2));
}
function ul(t2) {
  t2 = lc2(t2, gc2);
  const e = lc2(t2.firestore, vc2), n = Cc2(e), s = new nl(e);
  return tc2(n, t2._query, {
    source: "server"
  }).then((n2) => new Vh(e, s, t2, n2));
}
function al(t2, e, n) {
  t2 = lc2(t2, mc2);
  const s = lc2(t2.firestore, vc2), i = Yh(t2.converter, e, n);
  return _l(s, [nh(eh(s), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, yn.none())]);
}
function cl(t2, e, n, ...s) {
  t2 = lc2(t2, mc2);
  const i = lc2(t2.firestore, vc2), r = eh(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof Gc2 ? hh(r, "updateDoc", t2._key, e, n, s) : ch(r, "updateDoc", t2._key, e);
  return _l(i, [o.toMutation(t2._key, yn.exists(true))]);
}
function hl(t2) {
  return _l(lc2(t2.firestore, vc2), [new Cn(t2._key, yn.none())]);
}
function ll(t2, e) {
  const n = lc2(t2.firestore, vc2), s = Tc2(t2), i = Yh(t2.converter, e);
  return _l(n, [nh(eh(t2.firestore), "addDoc", s._key, i, t2.converter !== null, {}).toMutation(s._key, yn.exists(false))]).then(() => s);
}
function fl(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || Pc2(e[o]) || (r = e[o], o++);
  const u = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (Pc2(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let a, c, h;
  if (t2 instanceof mc2)
    c = lc2(t2.firestore, vc2), h = Fe(t2._key.path), a = {
      next: (n2) => {
        e[o] && e[o](wl(c, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = lc2(t2, gc2);
    c = lc2(n2.firestore, vc2), h = n2._query;
    const s2 = new nl(c);
    a = {
      next: (t3) => {
        e[o] && e[o](new Vh(c, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, Dh(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new Ma2(s2), r2 = new Uu(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => Ou(await za2(t3), r2)), () => {
      i2.Ia(), t3.asyncQueue.enqueueAndForget(async () => Fu(await za2(t3), r2));
    };
  }(Cc2(c), h, u, a);
}
function dl(t2, e) {
  return ec2(Cc2(t2 = lc2(t2, vc2)), Pc2(e) ? e : {
    next: e
  });
}
function _l(t2, e) {
  return function(t3, e2) {
    const n = new j();
    return t3.asyncQueue.enqueueAndForget(async () => ea2(await Wa2(t3), e2, n)), n.promise;
  }(Cc2(t2), e);
}
function wl(t2, e, n) {
  const s = n.docs.get(e._key), i = new nl(t2);
  return new Ph(t2, i, e._key, s, new Rh(n.hasPendingWrites, n.fromCache), e.converter);
}
var ml = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = eh(t2);
  }
  get(t2) {
    const e = tl(t2, this._firestore), n = new Xh(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return L2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new Th(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new Th(this._firestore, n, e._key, null, e.converter);
      throw L2();
    });
  }
  set(t2, e, n) {
    const s = tl(t2, this._firestore), i = Yh(s.converter, e, n), r = nh(this._dataReader, "Transaction.set", s._key, i, s.converter !== null, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = tl(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Gc2 ? hh(this._dataReader, "Transaction.update", i._key, e, n, s) : ch(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = tl(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = tl(t2, this._firestore), n = new nl(this._firestore);
    return super.get(t2).then((t3) => new Ph(this._firestore, n, e._key, t3._document, new Rh(false, false), e.converter));
  }
};
function gl(t2, e) {
  return nc2(Cc2(t2 = lc2(t2, vc2)), (n) => e(new ml(t2, n)));
}
function yl() {
  return new sh("deleteField");
}
function pl() {
  return new rh("serverTimestamp");
}
function Il(...t2) {
  return new oh("arrayUnion", t2);
}
function Tl(...t2) {
  return new uh("arrayRemove", t2);
}
function El(t2) {
  return new ah("increment", t2);
}
!function(t2, e = true) {
  !function(t3) {
    x2 = t3;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (t3, { options: n }) => {
    const s = t3.getProvider("app").getImmediate(), i = new vc2(s, new J2(t3.getProvider("auth-internal")), new tt(t3.getProvider("app-check-internal")));
    return n = Object.assign({
      useFetchStreams: e
    }, n), i._setSettings(n), i;
  }, "PUBLIC")), registerVersion(D2, "3.4.8", t2), registerVersion(D2, "3.4.8", "esm2017");
}();

// node_modules/@firebase/firestore-compat/dist/index.esm2017.js
var name = "@firebase/firestore-compat";
var version = "0.1.17";
function validateSetOptions(methodName, options) {
  if (options === void 0) {
    return {
      merge: false
    };
  }
  if (options.mergeFields !== void 0 && options.merge !== void 0) {
    throw new Q2("invalid-argument", `Invalid options passed to function ${methodName}(): You cannot specify both "merge" and "mergeFields".`);
  }
  return options;
}
function assertUint8ArrayAvailable() {
  if (typeof Uint8Array === "undefined") {
    throw new Q2("unimplemented", "Uint8Arrays are not available in this environment.");
  }
}
function assertBase64Available() {
  if (!yt()) {
    throw new Q2("unimplemented", "Blobs are unavailable in Firestore in this environment.");
  }
}
var Blob = class {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  static fromBase64String(base64) {
    assertBase64Available();
    return new Blob(jc2.fromBase64String(base64));
  }
  static fromUint8Array(array) {
    assertUint8ArrayAvailable();
    return new Blob(jc2.fromUint8Array(array));
  }
  toBase64() {
    assertBase64Available();
    return this._delegate.toBase64();
  }
  toUint8Array() {
    assertUint8ArrayAvailable();
    return this._delegate.toUint8Array();
  }
  isEqual(other) {
    return this._delegate.isEqual(other._delegate);
  }
  toString() {
    return "Blob(base64: " + this.toBase64() + ")";
  }
};
function isPartialObserver(obj) {
  return implementsAnyMethods(obj, ["next", "error", "complete"]);
}
function implementsAnyMethods(obj, methods) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const object = obj;
  for (const method of methods) {
    if (method in object && typeof object[method] === "function") {
      return true;
    }
  }
  return false;
}
var IndexedDbPersistenceProvider = class {
  enableIndexedDbPersistence(firestore, forceOwnership) {
    return Nc2(firestore._delegate, { forceOwnership });
  }
  enableMultiTabIndexedDbPersistence(firestore) {
    return kc2(firestore._delegate);
  }
  clearIndexedDbPersistence(firestore) {
    return Oc2(firestore._delegate);
  }
};
var Firestore = class {
  constructor(databaseIdOrApp, _delegate, _persistenceProvider) {
    this._delegate = _delegate;
    this._persistenceProvider = _persistenceProvider;
    this.INTERNAL = {
      delete: () => this.terminate()
    };
    if (!(databaseIdOrApp instanceof vt)) {
      this._appCompat = databaseIdOrApp;
    }
  }
  get _databaseId() {
    return this._delegate._databaseId;
  }
  settings(settingsLiteral) {
    const currentSettings = this._delegate._getSettings();
    if (!settingsLiteral.merge && currentSettings.host !== settingsLiteral.host) {
      $("You are overriding the original host. If you did not intend to override your settings, use {merge: true}.");
    }
    if (settingsLiteral.merge) {
      settingsLiteral = Object.assign(Object.assign({}, currentSettings), settingsLiteral);
      delete settingsLiteral.merge;
    }
    this._delegate._setSettings(settingsLiteral);
  }
  useEmulator(host, port, options = {}) {
    wc2(this._delegate, host, port, options);
  }
  enableNetwork() {
    return $c2(this._delegate);
  }
  disableNetwork() {
    return Bc2(this._delegate);
  }
  enablePersistence(settings) {
    let synchronizeTabs = false;
    let experimentalForceOwningTab = false;
    if (settings) {
      synchronizeTabs = !!settings.synchronizeTabs;
      experimentalForceOwningTab = !!settings.experimentalForceOwningTab;
      uc2("synchronizeTabs", synchronizeTabs, "experimentalForceOwningTab", experimentalForceOwningTab);
    }
    return synchronizeTabs ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, experimentalForceOwningTab);
  }
  clearPersistence() {
    return this._persistenceProvider.clearIndexedDbPersistence(this);
  }
  terminate() {
    if (this._appCompat) {
      this._appCompat._removeServiceInstance("firestore-compat");
      this._appCompat._removeServiceInstance("firestore");
    }
    return this._delegate._delete();
  }
  waitForPendingWrites() {
    return Fc2(this._delegate);
  }
  onSnapshotsInSync(arg) {
    return dl(this._delegate, arg);
  }
  get app() {
    if (!this._appCompat) {
      throw new Q2("failed-precondition", "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    }
    return this._appCompat;
  }
  collection(pathString) {
    try {
      return new CollectionReference(this, pc2(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "collection()", "Firestore.collection()");
    }
  }
  doc(pathString) {
    try {
      return new DocumentReference(this, Tc2(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "doc()", "Firestore.doc()");
    }
  }
  collectionGroup(collectionId) {
    try {
      return new Query(this, Ic2(this._delegate, collectionId));
    } catch (e) {
      throw replaceFunctionName(e, "collectionGroup()", "Firestore.collectionGroup()");
    }
  }
  runTransaction(updateFunction) {
    return gl(this._delegate, (transaction) => updateFunction(new Transaction(this, transaction)));
  }
  batch() {
    Cc2(this._delegate);
    return new WriteBatch(new Zh(this._delegate, (mutations) => _l(this._delegate, mutations)));
  }
  loadBundle(bundleData) {
    return Uc2(this._delegate, bundleData);
  }
  namedQuery(name2) {
    return qc2(this._delegate, name2).then((expQuery) => {
      if (!expQuery) {
        return null;
      }
      return new Query(this, expQuery);
    });
  }
};
var UserDataWriter = class extends Jh {
  constructor(firestore) {
    super();
    this.firestore = firestore;
  }
  convertBytes(bytes) {
    return new Blob(new jc2(bytes));
  }
  convertReference(name2) {
    const key = this.convertDocumentKey(name2, this.firestore._databaseId);
    return DocumentReference.forKey(key, this.firestore, null);
  }
};
function setLogLevel(level) {
  M2(level);
}
var Transaction = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(_firestore);
  }
  get(documentRef) {
    const ref = castReference(documentRef);
    return this._delegate.get(ref).then((result) => new DocumentSnapshot(this._firestore, new Ph(this._firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, ref.converter)));
  }
  set(documentRef, data, options) {
    const ref = castReference(documentRef);
    if (options) {
      validateSetOptions("Transaction.set", options);
      this._delegate.set(ref, data, options);
    } else {
      this._delegate.set(ref, data);
    }
    return this;
  }
  update(documentRef, dataOrField, value, ...moreFieldsAndValues) {
    const ref = castReference(documentRef);
    if (arguments.length === 2) {
      this._delegate.update(ref, dataOrField);
    } else {
      this._delegate.update(ref, dataOrField, value, ...moreFieldsAndValues);
    }
    return this;
  }
  delete(documentRef) {
    const ref = castReference(documentRef);
    this._delegate.delete(ref);
    return this;
  }
};
var WriteBatch = class {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  set(documentRef, data, options) {
    const ref = castReference(documentRef);
    if (options) {
      validateSetOptions("WriteBatch.set", options);
      this._delegate.set(ref, data, options);
    } else {
      this._delegate.set(ref, data);
    }
    return this;
  }
  update(documentRef, dataOrField, value, ...moreFieldsAndValues) {
    const ref = castReference(documentRef);
    if (arguments.length === 2) {
      this._delegate.update(ref, dataOrField);
    } else {
      this._delegate.update(ref, dataOrField, value, ...moreFieldsAndValues);
    }
    return this;
  }
  delete(documentRef) {
    const ref = castReference(documentRef);
    this._delegate.delete(ref);
    return this;
  }
  commit() {
    return this._delegate.commit();
  }
};
var FirestoreDataConverter = class {
  constructor(_firestore, _userDataWriter, _delegate) {
    this._firestore = _firestore;
    this._userDataWriter = _userDataWriter;
    this._delegate = _delegate;
  }
  fromFirestore(snapshot, options) {
    const expSnapshot = new bh(this._firestore._delegate, this._userDataWriter, snapshot._key, snapshot._document, snapshot.metadata, null);
    return this._delegate.fromFirestore(new QueryDocumentSnapshot(this._firestore, expSnapshot), options !== null && options !== void 0 ? options : {});
  }
  toFirestore(modelObject, options) {
    if (!options) {
      return this._delegate.toFirestore(modelObject);
    } else {
      return this._delegate.toFirestore(modelObject, options);
    }
  }
  static getInstance(firestore, converter) {
    const converterMapByFirestore = FirestoreDataConverter.INSTANCES;
    let untypedConverterByConverter = converterMapByFirestore.get(firestore);
    if (!untypedConverterByConverter) {
      untypedConverterByConverter = /* @__PURE__ */ new WeakMap();
      converterMapByFirestore.set(firestore, untypedConverterByConverter);
    }
    let instance = untypedConverterByConverter.get(converter);
    if (!instance) {
      instance = new FirestoreDataConverter(firestore, new UserDataWriter(firestore), converter);
      untypedConverterByConverter.set(converter, instance);
    }
    return instance;
  }
};
FirestoreDataConverter.INSTANCES = /* @__PURE__ */ new WeakMap();
var DocumentReference = class {
  constructor(firestore, _delegate) {
    this.firestore = firestore;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(firestore);
  }
  static forPath(path, firestore, converter) {
    if (path.length % 2 !== 0) {
      throw new Q2("invalid-argument", `Invalid document reference. Document references must have an even number of segments, but ${path.canonicalString()} has ${path.length}`);
    }
    return new DocumentReference(firestore, new mc2(firestore._delegate, converter, new xt(path)));
  }
  static forKey(key, firestore, converter) {
    return new DocumentReference(firestore, new mc2(firestore._delegate, converter, key));
  }
  get id() {
    return this._delegate.id;
  }
  get parent() {
    return new CollectionReference(this.firestore, this._delegate.parent);
  }
  get path() {
    return this._delegate.path;
  }
  collection(pathString) {
    try {
      return new CollectionReference(this.firestore, pc2(this._delegate, pathString));
    } catch (e) {
      throw replaceFunctionName(e, "collection()", "DocumentReference.collection()");
    }
  }
  isEqual(other) {
    other = getModularInstance(other);
    if (!(other instanceof mc2)) {
      return false;
    }
    return Ec2(this._delegate, other);
  }
  set(value, options) {
    options = validateSetOptions("DocumentReference.set", options);
    try {
      if (options) {
        return al(this._delegate, value, options);
      } else {
        return al(this._delegate, value);
      }
    } catch (e) {
      throw replaceFunctionName(e, "setDoc()", "DocumentReference.set()");
    }
  }
  update(fieldOrUpdateData, value, ...moreFieldsAndValues) {
    try {
      if (arguments.length === 1) {
        return cl(this._delegate, fieldOrUpdateData);
      } else {
        return cl(this._delegate, fieldOrUpdateData, value, ...moreFieldsAndValues);
      }
    } catch (e) {
      throw replaceFunctionName(e, "updateDoc()", "DocumentReference.update()");
    }
  }
  delete() {
    return hl(this._delegate);
  }
  onSnapshot(...args) {
    const options = extractSnapshotOptions(args);
    const observer = wrapObserver(args, (result) => new DocumentSnapshot(this.firestore, new Ph(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));
    return fl(this._delegate, options, observer);
  }
  get(options) {
    let snap;
    if ((options === null || options === void 0 ? void 0 : options.source) === "cache") {
      snap = sl(this._delegate);
    } else if ((options === null || options === void 0 ? void 0 : options.source) === "server") {
      snap = il(this._delegate);
    } else {
      snap = el(this._delegate);
    }
    return snap.then((result) => new DocumentSnapshot(this.firestore, new Ph(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));
  }
  withConverter(converter) {
    return new DocumentReference(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
};
function replaceFunctionName(e, original, updated) {
  e.message = e.message.replace(original, updated);
  return e;
}
function extractSnapshotOptions(args) {
  for (const arg of args) {
    if (typeof arg === "object" && !isPartialObserver(arg)) {
      return arg;
    }
  }
  return {};
}
function wrapObserver(args, wrapper) {
  var _a2, _b;
  let userObserver;
  if (isPartialObserver(args[0])) {
    userObserver = args[0];
  } else if (isPartialObserver(args[1])) {
    userObserver = args[1];
  } else if (typeof args[0] === "function") {
    userObserver = {
      next: args[0],
      error: args[1],
      complete: args[2]
    };
  } else {
    userObserver = {
      next: args[1],
      error: args[2],
      complete: args[3]
    };
  }
  return {
    next: (val) => {
      if (userObserver.next) {
        userObserver.next(wrapper(val));
      }
    },
    error: (_a2 = userObserver.error) === null || _a2 === void 0 ? void 0 : _a2.bind(userObserver),
    complete: (_b = userObserver.complete) === null || _b === void 0 ? void 0 : _b.bind(userObserver)
  };
}
var DocumentSnapshot = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get ref() {
    return new DocumentReference(this._firestore, this._delegate.ref);
  }
  get id() {
    return this._delegate.id;
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get exists() {
    return this._delegate.exists();
  }
  data(options) {
    return this._delegate.data(options);
  }
  get(fieldPath, options) {
    return this._delegate.get(fieldPath, options);
  }
  isEqual(other) {
    return Sh(this._delegate, other._delegate);
  }
};
var QueryDocumentSnapshot = class extends DocumentSnapshot {
  data(options) {
    const data = this._delegate.data(options);
    q2(data !== void 0, "Document in a QueryDocumentSnapshot should exist");
    return data;
  }
};
var Query = class {
  constructor(firestore, _delegate) {
    this.firestore = firestore;
    this._delegate = _delegate;
    this._userDataWriter = new UserDataWriter(firestore);
  }
  where(fieldPath, opStr, value) {
    try {
      return new Query(this.firestore, xh(this._delegate, kh(fieldPath, opStr, value)));
    } catch (e) {
      throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
    }
  }
  orderBy(fieldPath, directionStr) {
    try {
      return new Query(this.firestore, xh(this._delegate, Oh(fieldPath, directionStr)));
    } catch (e) {
      throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
    }
  }
  limit(n) {
    try {
      return new Query(this.firestore, xh(this._delegate, $h(n)));
    } catch (e) {
      throw replaceFunctionName(e, "limit()", "Query.limit()");
    }
  }
  limitToLast(n) {
    try {
      return new Query(this.firestore, xh(this._delegate, Bh(n)));
    } catch (e) {
      throw replaceFunctionName(e, "limitToLast()", "Query.limitToLast()");
    }
  }
  startAt(...args) {
    try {
      return new Query(this.firestore, xh(this._delegate, Uh(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "startAt()", "Query.startAt()");
    }
  }
  startAfter(...args) {
    try {
      return new Query(this.firestore, xh(this._delegate, qh(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "startAfter()", "Query.startAfter()");
    }
  }
  endBefore(...args) {
    try {
      return new Query(this.firestore, xh(this._delegate, Gh(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "endBefore()", "Query.endBefore()");
    }
  }
  endAt(...args) {
    try {
      return new Query(this.firestore, xh(this._delegate, Qh(...args)));
    } catch (e) {
      throw replaceFunctionName(e, "endAt()", "Query.endAt()");
    }
  }
  isEqual(other) {
    return Ac2(this._delegate, other._delegate);
  }
  get(options) {
    let query;
    if ((options === null || options === void 0 ? void 0 : options.source) === "cache") {
      query = ol(this._delegate);
    } else if ((options === null || options === void 0 ? void 0 : options.source) === "server") {
      query = ul(this._delegate);
    } else {
      query = rl(this._delegate);
    }
    return query.then((result) => new QuerySnapshot(this.firestore, new Vh(this.firestore._delegate, this._userDataWriter, this._delegate, result._snapshot)));
  }
  onSnapshot(...args) {
    const options = extractSnapshotOptions(args);
    const observer = wrapObserver(args, (snap) => new QuerySnapshot(this.firestore, new Vh(this.firestore._delegate, this._userDataWriter, this._delegate, snap._snapshot)));
    return fl(this._delegate, options, observer);
  }
  withConverter(converter) {
    return new Query(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
};
var DocumentChange = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get type() {
    return this._delegate.type;
  }
  get doc() {
    return new QueryDocumentSnapshot(this._firestore, this._delegate.doc);
  }
  get oldIndex() {
    return this._delegate.oldIndex;
  }
  get newIndex() {
    return this._delegate.newIndex;
  }
};
var QuerySnapshot = class {
  constructor(_firestore, _delegate) {
    this._firestore = _firestore;
    this._delegate = _delegate;
  }
  get query() {
    return new Query(this._firestore, this._delegate.query);
  }
  get metadata() {
    return this._delegate.metadata;
  }
  get size() {
    return this._delegate.size;
  }
  get empty() {
    return this._delegate.empty;
  }
  get docs() {
    return this._delegate.docs.map((doc) => new QueryDocumentSnapshot(this._firestore, doc));
  }
  docChanges(options) {
    return this._delegate.docChanges(options).map((docChange) => new DocumentChange(this._firestore, docChange));
  }
  forEach(callback, thisArg) {
    this._delegate.forEach((snapshot) => {
      callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, snapshot));
    });
  }
  isEqual(other) {
    return Sh(this._delegate, other._delegate);
  }
};
var CollectionReference = class extends Query {
  constructor(firestore, _delegate) {
    super(firestore, _delegate);
    this.firestore = firestore;
    this._delegate = _delegate;
  }
  get id() {
    return this._delegate.id;
  }
  get path() {
    return this._delegate.path;
  }
  get parent() {
    const docRef = this._delegate.parent;
    return docRef ? new DocumentReference(this.firestore, docRef) : null;
  }
  doc(documentPath) {
    try {
      if (documentPath === void 0) {
        return new DocumentReference(this.firestore, Tc2(this._delegate));
      } else {
        return new DocumentReference(this.firestore, Tc2(this._delegate, documentPath));
      }
    } catch (e) {
      throw replaceFunctionName(e, "doc()", "CollectionReference.doc()");
    }
  }
  add(data) {
    return ll(this._delegate, data).then((docRef) => new DocumentReference(this.firestore, docRef));
  }
  isEqual(other) {
    return Ec2(this._delegate, other._delegate);
  }
  withConverter(converter) {
    return new CollectionReference(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
  }
};
function castReference(documentRef) {
  return lc2(documentRef, mc2);
}
var FieldPath = class {
  constructor(...fieldNames) {
    this._delegate = new Gc2(...fieldNames);
  }
  static documentId() {
    return new FieldPath(mt.keyField().canonicalString());
  }
  isEqual(other) {
    other = getModularInstance(other);
    if (!(other instanceof Gc2)) {
      return false;
    }
    return this._delegate._internalPath.isEqual(other._internalPath);
  }
};
var FieldValue = class {
  constructor(_delegate) {
    this._delegate = _delegate;
  }
  static serverTimestamp() {
    const delegate = pl();
    delegate._methodName = "FieldValue.serverTimestamp";
    return new FieldValue(delegate);
  }
  static delete() {
    const delegate = yl();
    delegate._methodName = "FieldValue.delete";
    return new FieldValue(delegate);
  }
  static arrayUnion(...elements) {
    const delegate = Il(...elements);
    delegate._methodName = "FieldValue.arrayUnion";
    return new FieldValue(delegate);
  }
  static arrayRemove(...elements) {
    const delegate = Tl(...elements);
    delegate._methodName = "FieldValue.arrayRemove";
    return new FieldValue(delegate);
  }
  static increment(n) {
    const delegate = El(n);
    delegate._methodName = "FieldValue.increment";
    return new FieldValue(delegate);
  }
  isEqual(other) {
    return this._delegate.isEqual(other._delegate);
  }
};
var firestoreNamespace = {
  Firestore,
  GeoPoint: zc2,
  Timestamp: at,
  Blob,
  Transaction,
  WriteBatch,
  DocumentReference,
  DocumentSnapshot,
  Query,
  QueryDocumentSnapshot,
  QuerySnapshot,
  CollectionReference,
  FieldPath,
  FieldValue,
  setLogLevel,
  CACHE_SIZE_UNLIMITED: Vc2
};
function configureForFirebase(firebase2, firestoreFactory) {
  firebase2.INTERNAL.registerComponent(new Component("firestore-compat", (container) => {
    const app = container.getProvider("app-compat").getImmediate();
    const firestoreExp = container.getProvider("firestore").getImmediate();
    return firestoreFactory(app, firestoreExp);
  }, "PUBLIC").setServiceProps(Object.assign({}, firestoreNamespace)));
}
function registerFirestore(instance) {
  configureForFirebase(instance, (app, firestoreExp) => new Firestore(app, firestoreExp, new IndexedDbPersistenceProvider()));
  instance.registerVersion(name, version);
}
registerFirestore(firebase);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=firebase_compat_firestore.js.map
